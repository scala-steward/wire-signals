<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.com" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="com" class="anchorToMember"></a><a id="com:com" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">com</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="com.wire" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wire" class="anchorToMember"></a><a id="wire:wire" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">wire</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="com" id="com" class="extype">com</a></dd></dl></div></li><li class="indented3 " name="com.wire.signals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="signals" class="anchorToMember"></a><a id="signals:signals" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="index.html" title=""><span class="name">signals</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="com.wire" id="com.wire" class="extype">wire</a></dd></dl></div></li><li class="indented4 " name="com.wire.signals.ui" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ui" class="anchorToMember"></a><a id="ui:ui" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ui/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="ui/index.html" title=""><span class="name">ui</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="index.html" name="com.wire.signals" id="com.wire.signals" class="extype">signals</a></dd></dl></div></li><li class="current-entities indented3"><a href="AggregatingSignal$.html" title="" class="object"></a> <a href="AggregatingSignal.html" title="A signal which initializes its value by executing the loader future and then updates the value by composition of the previous value and an event published in the associated source stream." class="class"></a><a href="AggregatingSignal.html" title="A signal which initializes its value by executing the loader future and then updates the value by composition of the previous value and an event published in the associated source stream.">AggregatingSignal</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="BaseEventContext.html" title="" class="class"></a><a href="BaseEventContext.html" title="">BaseEventContext</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="BaseSubscription.html" title="Provides the default implementation of the Subscription trait." class="class"></a><a href="BaseSubscription.html" title="Provides the default implementation of the Subscription trait.">BaseSubscription</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Cancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually cancellable." class="class"></a><a href="Cancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually cancellable.">Cancellable</a></li><li class="current-entities indented3"><a href="CancellableFuture$.html" title="CancellableFuture is an object that for all practical uses works like a future but enables the user to cancel the operation." class="object"></a> <a href="CancellableFuture.html" title="CancellableFuture is an object that for all practical uses works like a future but enables the user to cancel the operation." class="class"></a><a href="CancellableFuture.html" title="CancellableFuture is an object that for all practical uses works like a future but enables the user to cancel the operation.">CancellableFuture</a></li><li class="current-entities indented3"><a href="ConstSignal$.html" title="" class="object"></a> <a href="ConstSignal.html" title="A signal holding an immutable value." class="class"></a><a href="ConstSignal.html" title="A signal holding an immutable value.">ConstSignal</a></li><li class="current-entities indented3"><a href="DispatchQueue$.html" title="" class="object"></a> <a href="DispatchQueue.html" title="A thin wrapper over Scala's ExecutionContext allowing us to differentiate between the default execution context which tries to run asynchronously as many tasks as possible, and limited execution contexts, allowed to run only up to a given number of tasks at once." class="trait"></a><a href="DispatchQueue.html" title="A thin wrapper over Scala's ExecutionContext allowing us to differentiate between the default execution context which tries to run asynchronously as many tasks as possible, and limited execution contexts, allowed to run only up to a given number of tasks at once.">DispatchQueue</a></li><li class="current-entities indented3"><a href="EventContext$.html" title="" class="object"></a> <a href="EventContext.html" title="When you subscribe to an EventSource in return you receive a Subscription." class="trait"></a><a href="EventContext.html" title="When you subscribe to an EventSource in return you receive a Subscription.">EventContext</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="EventSource.html" title="" class="class"></a><a href="EventSource.html" title="">EventSource</a></li><li class="current-entities indented3"><a href="EventStream$.html" title="" class="object"></a> <a href="EventStream.html" title="An event stream of type E dispatches events (of type E) to all functions of type (E) =&gt; Unit which were registered in the event stream as its subscribers." class="class"></a><a href="EventStream.html" title="An event stream of type E dispatches events (of type E) to all functions of type (E) =&gt; Unit which were registered in the event stream as its subscribers.">EventStream</a></li><li class="current-entities indented3"><a href="EventStreamWithAuxSignal$.html" title="" class="object"></a> <a href="EventStreamWithAuxSignal.html" title="An event stream coupled with an auxiliary signal." class="class"></a><a href="EventStreamWithAuxSignal.html" title="An event stream coupled with an auxiliary signal.">EventStreamWithAuxSignal</a></li><li class="current-entities indented3"><a href="LimitedDispatchQueue$.html" title="" class="object"></a> <a href="LimitedDispatchQueue.html" title="A dispatch queue limiting number of concurrently executing tasks." class="class"></a><a href="LimitedDispatchQueue.html" title="A dispatch queue limiting number of concurrently executing tasks.">LimitedDispatchQueue</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="NoAutowiring.html" title="By default, a new signal is initialized lazily, i.e." class="trait"></a><a href="NoAutowiring.html" title="By default, a new signal is initialized lazily, i.e.">NoAutowiring</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ProxyEventStream.html" title="A superclass for all event streams which compose other event streams into one." class="class"></a><a href="ProxyEventStream.html" title="A superclass for all event streams which compose other event streams into one.">ProxyEventStream</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ProxySignal.html" title="" class="class"></a><a href="ProxySignal.html" title="">ProxySignal</a></li><li class="current-entities indented3"><a href="RefreshingSignal$.html" title="" class="object"></a> <a href="RefreshingSignal.html" title="A signal which initializes its value by executing the loader cancellable future and then updates the value the same way every time a new refresh event is published in the associated event stream." class="class"></a><a href="RefreshingSignal.html" title="A signal which initializes its value by executing the loader cancellable future and then updates the value the same way every time a new refresh event is published in the associated event stream.">RefreshingSignal</a></li><li class="current-entities indented3"><a href="SerialDispatchQueue$.html" title="" class="object"></a> <a href="SerialDispatchQueue.html" title="A special case of a limited dispatch queue which allows for only one task to be executed at once." class="class"></a><a href="SerialDispatchQueue.html" title="A special case of a limited dispatch queue which allows for only one task to be executed at once.">SerialDispatchQueue</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Serialized$.html" title="A utility object for serializing futures." class="object"></a><a href="Serialized$.html" title="A utility object for serializing futures.">Serialized</a></li><li class="current-entities indented3"><a href="Signal$.html" title="" class="object"></a> <a href="" title="A signal is an event stream with a cache." class="class"></a><a href="" title="A signal is an event stream with a cache.">Signal</a></li><li class="current-entities indented3"><a href="SourceSignal$.html" title="" class="object"></a> <a href="SourceSignal.html" title="The usual entry point for publishing values in signals." class="class"></a><a href="SourceSignal.html" title="The usual entry point for publishing values in signals.">SourceSignal</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="SourceStream.html" title="The usual entry point for publishing events." class="class"></a><a href="SourceStream.html" title="The usual entry point for publishing events.">SourceStream</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Subscription.html" title="When you add a new subscriber to your EventStream or Signal, in return you get a Subscription." class="trait"></a><a href="Subscription.html" title="When you add a new subscriber to your EventStream or Signal, in return you get a Subscription.">Subscription</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Threading$.html" title="Use Threading to set up the default execution context which will be later used as the parent for other dispatch queues and to run cancellable futures, event streams, and signals, if no other execution context is provided." class="object"></a><a href="Threading$.html" title="Use Threading to set up the default execution context which will be later used as the parent for other dispatch queues and to run cancellable futures, event streams, and signals, if no other execution context is provided.">Threading</a></li><li class="current-entities indented3"><a href="ThrottledSignal$.html" title="" class="object"></a> <a href="ThrottledSignal.html" title="A signal which publishes changes of its parent signal but no more often than once during a given time interval." class="class"></a><a href="ThrottledSignal.html" title="A signal which publishes changes of its parent signal but no more often than once during a given time interval.">ThrottledSignal</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Uncancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually **un**cancellable." class="class"></a><a href="Uncancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually **un**cancellable.">Uncancellable</a></li><li class="current-entities indented3"><a href="UnlimitedDispatchQueue$.html" title="" class="object"></a> <a href="UnlimitedDispatchQueue.html" title="A dispatch queue that simply passes all its tasks to its execution context." class="class"></a><a href="UnlimitedDispatchQueue.html" title="A dispatch queue that simply passes all its tasks to its execution context.">UnlimitedDispatchQueue</a></li></ul></div></div><div id="content"><body class="class type"><div id="definition"><a href="Signal$.html" title="See companion object"><div class="big-circle class-companion-object">c</div></a><p id="owner"><a href="../../index.html" name="com" id="com" class="extype">com</a>.<a href="../index.html" name="com.wire" id="com.wire" class="extype">wire</a>.<a href="index.html" name="com.wire.signals" id="com.wire.signals" class="extype">signals</a></p><h1><a href="Signal$.html" title="See companion object">Signal</a><span class="permalink"><a href="../../../com/wire/signals/Signal.html" title="Permalink"><i class="material-icons"></i></a></span></h1><h3><span class="morelinks"><div>Companion <a href="Signal$.html" title="See companion object">object Signal</a></div></span></h3></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><span class="name">Signal</span><span class="tparams">[<span name="V">V</span>]</span><span class="result"> extends <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="com.wire.signals.Signal.SignalSubscriber" class="extype">SignalSubscriber</span>]</span></span></h4><div id="comment" class="fullcommenttop"><div class="comment cmt"><p>A signal is an event stream with a cache.</p><p>Whereas an event stream holds no internal state and just passes on events it receives, a signal keeps the last value it received.
A new subscriber function registered in an event stream will be called only when a new event is published.
A new subscriber function registered in a signal will be called immediately (or as soon as possible on the given execution context)
with the current value of the signal (unless it's not initialized yet) and then again when the value changes.
A signal is also able to compare a new value published in it with the old one - the new value will be passed on only if
it is different. Thus, a signal can help us with optimizing performance on both ends: as a cache for values which otherwise
would require expensive computations to produce them every time we need them, and as a way to ensure that subscriber functions
are called only when the value actually changes, but not when the result of the intermediate computation is the same as before.</p><p>Note that for clarity we talk about *events* in the event streams, but about *values* in signals.</p><p>An signal of the type <code>V</code> dispatches values to all functions of the type <code>(V) =&gt; Unit</code> which were registered in
the signal as its subscribers. It provides a handful of methods which enable the user to create new signals by means of composing
the old ones, filtering them, etc., in a way similar to how the user can operate on standard collections, as well as to interact with
Scala futures, cancellable futures, and event streams. Please note that by default a signal is not able to receive events from the outside -
that functionality belongs to <a href="SourceSignal.html" name="com.wire.signals.SourceSignal" id="com.wire.signals.SourceSignal" class="extype">SourceSignal</a>.
</p></div><dl class="paramcmts block"><dt class="tparam">V</dt><dd class="cmt"><p>The type of the value held in the signal.</p></dd></dl><dl class="attributes block"><dt>Self Type</dt><dd><a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</dd><dt>See also</dt><dd><span class="cmt"><p><a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a></p></span></dd></dl><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="com.wire.signals.Signal.SignalSubscriber" class="extype">SignalSubscriber</span>], <span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div><div class="toggleContainer"><div class="toggle block"><span>Known Subclasses</span><div class="subClasses hiddenContent"><a href="AggregatingSignal.html" name="com.wire.signals.AggregatingSignal" id="com.wire.signals.AggregatingSignal" class="extype">AggregatingSignal</a>, <a href="ConstSignal.html" name="com.wire.signals.ConstSignal" id="com.wire.signals.ConstSignal" class="extype">ConstSignal</a>, <a href="ProxySignal.html" name="com.wire.signals.ProxySignal" id="com.wire.signals.ProxySignal" class="extype">ProxySignal</a>, <a href="RefreshingSignal.html" name="com.wire.signals.RefreshingSignal" id="com.wire.signals.RefreshingSignal" class="extype">RefreshingSignal</a>, <a href="SourceSignal.html" name="com.wire.signals.SourceSignal" id="com.wire.signals.SourceSignal" class="extype">SourceSignal</a>, <a href="ThrottledSignal.html" name="com.wire.signals.ThrottledSignal" id="com.wire.signals.ThrottledSignal" class="extype">ThrottledSignal</a></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="com.wire.signals.Signal"><span>Signal</span></li><li class="in" name="com.wire.signals.EventSource"><span>EventSource</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="constructors" class="members"><h3>Instance Constructors</h3><ol><li class="indented0 " name="com.wire.signals.Signal#&lt;init&gt;" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="&lt;init&gt;(value:Option[V]):com.wire.signals.Signal[V]" class="anchorToMember"></a><a id="&lt;init&gt;:Signal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#&lt;init&gt;(value:Option[V]):com.wire.signals.Signal[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">new</span></span> <span class="symbol"><span class="name">Signal</span><span class="params">(<span name="value">value: <span name="scala.Option" class="extype">Option</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>] = <span class="symbol">None</span></span>)</span></span><p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">value</dt><dd class="cmt"><p>The option of the last value published in the signal or <code>None</code> if the signal was not initialized yet.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd></dl></div></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="scala.AnyRef#!=" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="!=(x$1:Any):Boolean" class="anchorToMember"></a><a id="!=(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#!=(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef###" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="##:Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html###:Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $hash$hash">##</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#==" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="==(x$1:Any):Boolean" class="anchorToMember"></a><a id="==(Any):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#==(x$1:Any):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="scala.Any#asInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="asInstanceOf[T0]:T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#asInstanceOf[T0]:T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Any.asInstanceOf.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#clone" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="clone():Object" class="anchorToMember"></a><a id="clone():AnyRef" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#clone():Object" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">clone</span><span class="params">()</span><span class="result">: <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.CloneNotSupportedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#collect" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="collect[Z](pf:PartialFunction[V,Z]):com.wire.signals.Signal[Z]" class="anchorToMember"></a><a id="collect[Z](PartialFunction[V,Z]):Signal[Z]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#collect[Z](pf:PartialFunction[V,Z]):com.wire.signals.Signal[Z]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">collect</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="pf">pf: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="com.wire.signals.Signal.collect.Z" class="extype">Z</span>]</span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.collect.Z" class="extype">Z</span>]</span></span><p class="shortcomment cmt">Creates a new signal of values of the type <code>Z</code> by applying a partial function which maps the original value of the type <code>V</code>
to a value of the type <code>Z</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new signal of values of the type <code>Z</code> by applying a partial function which maps the original value of the type <code>V</code>
to a value of the type <code>Z</code>. If the partial function doesn't work for the current value, the new signal will become empty
until the next update. Basically, it's filter + map.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The value type of the new signal.</p></dd><dt class="param">pf</dt><dd class="cmt"><p>A partial function which for the original value of the type <code>V</code> may produce a value of the type <code>Z</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal with values of the type <code>Z</code>, holding the value produced from the original signal's value by
        the partial function, or empty if that's not possible.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#combine" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="combine[Z,Y](other:com.wire.signals.Signal[Z])(f:(V,Z)=&gt;Y):com.wire.signals.Signal[Y]" class="anchorToMember"></a><a id="combine[Z,Y](Signal[Z])((V,Z)=&gt;Y):Signal[Y]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#combine[Z,Y](other:com.wire.signals.Signal[Z])(f:(V,Z)=&gt;Y):com.wire.signals.Signal[Y]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">combine</span><span class="tparams">[<span name="Z">Z</span>, <span name="Y">Y</span>]</span><span class="params">(<span name="other">other: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.combine.Z" class="extype">Z</span>]</span>)</span><span class="params">(<span name="f">f: (<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="com.wire.signals.Signal.combine.Z" class="extype">Z</span>) =&gt; <span name="com.wire.signals.Signal.combine.Y" class="extype">Y</span></span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.combine.Y" class="extype">Y</span>]</span></span><p class="shortcomment cmt">Combines the current values of this and another signal of the same or different types <code>V</code> and <code>Z</code> to produce a signal with the value
of yet another type <code>Y</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Combines the current values of this and another signal of the same or different types <code>V</code> and <code>Z</code> to produce a signal with the value
of yet another type <code>Y</code>. Basically, zip + map.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The value type of the other signal.</p></dd><dt class="tparam">Y</dt><dd class="cmt"><p>The value type of the new signal.</p></dd><dt class="param">other</dt><dd class="cmt"><p>The other signal with values of the same or a different type.</p></dd><dt class="param">f</dt><dd class="cmt"><p>The function which combines the current values of both parent signals to produce the value of the new signal.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal with the value of the type <code>Y</code>.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#contains" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="contains(value:V)(implicitec:scala.concurrent.ExecutionContext):scala.concurrent.Future[Boolean]" class="anchorToMember"></a><a id="contains(V)(ExecutionContext):Future[Boolean]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#contains(value:V)(implicitec:scala.concurrent.ExecutionContext):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">contains</span><span class="params">(<span name="value">value: <span name="com.wire.signals.Signal.V" class="extype">V</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ec">ec: <span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span></span>)</span><span class="result">: <span name="scala.concurrent.Future" class="extype">Future</span>[<span name="scala.Boolean" class="extype">Boolean</span>]</span></span><p class="shortcomment cmt">A shortcut that checks if the current value (or the first value after initialization) is the given one.</p><div class="fullcomment"><div class="comment cmt"><p>A shortcut that checks if the current value (or the first value after initialization) is the given one.
</p></div><dl class="paramcmts block"><dt class="param">value</dt><dd class="cmt"><p>The value to test</p></dd><dt class="param">ec</dt><dd class="cmt"><p>The execution context on which the check will be done</p></dd><dt>returns</dt><dd class="cmt"><p>a future of boolean: true if the signal contains the given value, false otherwise</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#currentValue" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="currentValue:Option[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#currentValue:Option[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">currentValue</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">The current value of the signal.</p><div class="fullcomment"><div class="comment cmt"><p>The current value of the signal.
If the signal requires some initial work before accessing its value for the first time, it will be done exactly one time.
Subsequently, this method will simply return the current value.</p><p>Please note that this will return an option of the value type. You may get a <code>None</code> if the signal is not initialized yet
or if it was temporarily cleared and awaits another update. Usually, it's safer to use <code>head</code> or <code>future</code> and work with
a future of the value type instead. And if you need to know if the signal is currently empty, use <code>empty</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The current value of the signal.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource#disableAutowiring" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="disableAutowiring():EventSource.this.type" class="anchorToMember"></a><a id="disableAutowiring():Signal.this.type" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#disableAutowiring():EventSource.this.type" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">disableAutowiring</span><span class="params">()</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>.this.type</span></span><p class="shortcomment cmt">Typically, a newly created event streams and signals are lazy in the sense that till there are no subscriptions to them,
they will not execute any intermediate computations (e.g.</p><div class="fullcomment"><div class="comment cmt"><p>Typically, a newly created event streams and signals are lazy in the sense that till there are no subscriptions to them,
they will not execute any intermediate computations (e.g. assembled to it through maps, flatMaps, etc). After all,
those computations would be ignored at the end. Only when a subscription is created, the computations are performed
for the first time.
<code>disableAutowiring</code> enforces those computations even if there are no subscribers. It can be useful if e.g. the computations
perform side-effects or if it's important from the performance point of view to have the intermediate results ready
when the subscriber is created.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The current instance, so that <code>disableAutoworing</code> can be chained with other method calls.</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#either" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="either[Z](fallback:com.wire.signals.Signal[Z]):com.wire.signals.Signal[Either[Z,V]]" class="anchorToMember"></a><a id="either[Z](Signal[Z]):Signal[Either[Z,V]]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#either[Z](fallback:com.wire.signals.Signal[Z]):com.wire.signals.Signal[Either[Z,V]]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">either</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="fallback">fallback: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.either.Z" class="extype">Z</span>]</span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="scala.Either" class="extype">Either</span>[<span name="com.wire.signals.Signal.either.Z" class="extype">Z</span>, <span name="com.wire.signals.Signal.V" class="extype">V</span>]]</span></span><p class="shortcomment cmt">A generalization of the <code>orElse</code> method where the fallback signal can have another value type.</p><div class="fullcomment"><div class="comment cmt"><p>A generalization of the <code>orElse</code> method where the fallback signal can have another value type.
If the value of this signal is <code>V</code> and the value of the fallback signal is <code>Z</code>, the new signal will return
an <code>Either[Z, V]</code>. When the parent signal is set, the value of the new signal will be <code>Right(v)</code>. When the parent
signal becomes empty, the value of the new signal will temporarily switch to <code>Left(z)</code> where <code>z</code> is the current value
of the fallback signal. The moment the parent signal is set to a new value again, the new signal will switch back to
<code>Right(v)</code>.
Only when both signals are empty, the new signal will become empty too.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The value type of the fallback signal.</p></dd><dt class="param">fallback</dt><dd class="cmt"><p>Another signal of the same or different value type.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal with the value being either the value of the parent or the value of the fallback signal if
        the parent is empty.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#empty" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="empty:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#empty:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">empty</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Checks if the signal is currently empty.</p><div class="fullcomment"><div class="comment cmt"><p>Checks if the signal is currently empty.
A signal is usually empty just after creation, if it was not initialized with a value, and it still waits
for the first value to be sent to it. Or it can be a constant <code>Signal.empty[V]</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if the signal is empty, false otherwise.</p></dd></dl><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd><dt>See also</dt><dd><span class="cmt"><p><a href="Signal$.html#empty[V]:com.wire.signals.Signal[V]" name="com.wire.signals.Signal#empty" id="com.wire.signals.Signal#empty" class="extmbr">Signal.empty</a></p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#eq" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="eq(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="eq(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#eq(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#equals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="equals(x$1:Object):Boolean" class="anchorToMember"></a><a id="equals(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#equals(x$1:Object):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#exists" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="exists(f:V=&gt;Boolean)(implicitec:scala.concurrent.ExecutionContext):scala.concurrent.Future[Boolean]" class="anchorToMember"></a><a id="exists((V)=&gt;Boolean)(ExecutionContext):Future[Boolean]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#exists(f:V=&gt;Boolean)(implicitec:scala.concurrent.ExecutionContext):scala.concurrent.Future[Boolean]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">exists</span><span class="params">(<span name="f">f: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ec">ec: <span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span></span>)</span><span class="result">: <span name="scala.concurrent.Future" class="extype">Future</span>[<span name="scala.Boolean" class="extype">Boolean</span>]</span></span><p class="shortcomment cmt">A shortcut that checks if the current value (or the first value after initialization) fulfills the given condition.</p><div class="fullcomment"><div class="comment cmt"><p>A shortcut that checks if the current value (or the first value after initialization) fulfills the given condition.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>The condition tested on the signal's value</p></dd><dt class="param">ec</dt><dd class="cmt"><p>The execution context on which the check will be done</p></dd><dt>returns</dt><dd class="cmt"><p>a future of boolean: true if the signal's value fulfills the given condition, false otherwise</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#filter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="filter(f:V=&gt;Boolean):com.wire.signals.Signal[V]" class="anchorToMember"></a><a id="filter((V)=&gt;Boolean):Signal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#filter(f:V=&gt;Boolean):com.wire.signals.Signal[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">filter</span><span class="params">(<span name="f">f: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">Creates a new <code>Signal[V]</code> which updates its value only if the new value of the original signal satisfies the filter,
and changes to empty otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <code>Signal[V]</code> which updates its value only if the new value of the original signal satisfies the filter,
and changes to empty otherwise. Also, if the initial value of the original signal does not satisfy the filter,
the new signal will start empty.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>A filtering function which for any value of the original signal returns true or false.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal of the same value type.</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#finalize" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="finalize():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#finalize():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<span name="java.lang" class="extype">lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="symbol">classOf[java.lang.Throwable]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#flatMap" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatMap[Z](f:V=&gt;com.wire.signals.Signal[Z]):com.wire.signals.Signal[Z]" class="anchorToMember"></a><a id="flatMap[Z]((V)=&gt;Signal[Z]):Signal[Z]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#flatMap[Z](f:V=&gt;com.wire.signals.Signal[Z]):com.wire.signals.Signal[Z]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatMap</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="f">f: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.flatMap.Z" class="extype">Z</span>]</span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.flatMap.Z" class="extype">Z</span>]</span></span><p class="shortcomment cmt">Creates a new <code>Signal[Z]</code> by mapping each event of the original <code>Signal[V]</code> to a new signal and switching to it.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <code>Signal[Z]</code> by mapping each event of the original <code>Signal[V]</code> to a new signal and switching to it.
The usual use case is to create a new complex signal not as one big entity with the value being the result of
computations based on a lot of data at once, but to break it into simpler signals connected by flatMaps. At each
step the used signal produces an intermediate value and recomputing that value is not necessary again until
the values used to compute that one are changed too.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The value type of the new signal.</p></dd><dt class="param">f</dt><dd class="cmt"><p>The function mapping each event of type <code>v</code> to a signal of the type <code>Z</code>.</p></dd><dt>returns</dt><dd class="cmt"><p>A new or already existing signal to which we switch as the result of a change in the value of the original signal.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#flatten" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="flatten[Z](implicitevidence:V&lt;:&lt;com.wire.signals.Signal[Z]):com.wire.signals.Signal[Z]" class="anchorToMember"></a><a id="flatten[Z](&lt;:&lt;[V,Signal[Z]]):Signal[Z]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#flatten[Z](implicitevidence:V&lt;:&lt;com.wire.signals.Signal[Z]):com.wire.signals.Signal[Z]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">flatten</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="evidence">evidence: <span name="scala.&lt;:&lt;" class="extype">&lt;:&lt;</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>, <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.flatten.Z" class="extype">Z</span>]]</span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.flatten.Z" class="extype">Z</span>]</span></span><p class="shortcomment cmt">Flattens a signal whose value type is also a signal.</p><div class="fullcomment"><div class="comment cmt"><p>Flattens a signal whose value type is also a signal.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The type of the value of the nested signal.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal of the value type the same as the value type of the nested signal.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource#foreach" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="foreach(body:E=&gt;Unit)(implicitexecutionContext:scala.concurrent.ExecutionContext,impliciteventContext:com.wire.signals.EventContext):com.wire.signals.Subscription" class="anchorToMember"></a><a id="foreach((V)=&gt;Unit)(ExecutionContext,EventContext):Subscription" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#foreach(body:E=&gt;Unit)(implicitexecutionContext:scala.concurrent.ExecutionContext,impliciteventContext:com.wire.signals.EventContext):com.wire.signals.Subscription" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">foreach</span><span class="params">(<span name="body">body: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="executionContext">executionContext: <span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span> = <span class="symbol"><span class="name"><a href="Threading$.html">Threading.defaultContext</a></span></span></span>, <span name="eventContext">eventContext: <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> = <span class="symbol"><span class="name"><a href="EventContext$.html">EventContext.Global</a></span></span></span>)</span><span class="result">: <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a></span></span><p class="shortcomment cmt">An alias for the <code>on</code> method with the default <span name="ExecutionContext" class="extype">ExecutionContext</span>.</p><div class="fullcomment"><div class="comment cmt"><p>An alias for the <code>on</code> method with the default <span name="ExecutionContext" class="extype">ExecutionContext</span>.</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#future" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="future:scala.concurrent.Future[V]" class="anchorToMember"></a><a id="future:Future[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#future:scala.concurrent.Future[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">future</span><span class="result">: <span name="scala.concurrent.Future" class="extype">Future</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">A future with the current value of the signal.</p><div class="fullcomment"><div class="comment cmt"><p>A future with the current value of the signal.
The future will finish immediately with the current value of the signal if the value is already set. If the signal is empty,
the future will finish when the next update sets the value.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The current value of the signal or the value it will be set to in the next update.</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#getClass" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="getClass():Class[_]" class="anchorToMember"></a><a id="getClass():Class[_&lt;:AnyRef]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#getClass():Class[_]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">getClass</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#java.lang.Class" name="java.lang.Class" id="java.lang.Class" class="extype">Class</a>[_ &lt;: <span name="scala.AnyRef" class="extype">AnyRef</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource#hasSubscribers" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hasSubscribers:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#hasSubscribers:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hasSubscribers</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Checks if there are any subscribers registered in this <code>EventRelay</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Checks if there are any subscribers registered in this <code>EventRelay</code>.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if any subscribers are registered, false otherwise</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#hashCode" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="hashCode():Int" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#hashCode():Int" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#head" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="head:scala.concurrent.Future[V]" class="anchorToMember"></a><a id="head:Future[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#head:scala.concurrent.Future[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">head</span><span class="result">: <span name="scala.concurrent.Future" class="extype">Future</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">An alias to the <code>future</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>An alias to the <code>future</code> method.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.Any#isInstanceOf" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="isInstanceOf[T0]:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#isInstanceOf[T0]:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>Any</dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#map" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="map[Z](f:V=&gt;Z):com.wire.signals.Signal[Z]" class="anchorToMember"></a><a id="map[Z]((V)=&gt;Z):Signal[Z]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#map[Z](f:V=&gt;Z):com.wire.signals.Signal[Z]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">map</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="f">f: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="com.wire.signals.Signal.map.Z" class="extype">Z</span></span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.map.Z" class="extype">Z</span>]</span></span><p class="shortcomment cmt">Creates a new <code>Signal[Z]</code> by mapping the value of the type <code>V</code> of this signal.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new <code>Signal[Z]</code> by mapping the value of the type <code>V</code> of this signal.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The value type of the new signal.</p></dd><dt class="param">f</dt><dd class="cmt"><p>The function mapping the value of the original signal into the value of the new signal.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal</p></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#ne" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ne(x$1:AnyRef):Boolean" class="anchorToMember"></a><a id="ne(AnyRef):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#ne(x$1:AnyRef):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span name="scala.AnyRef" class="extype">AnyRef</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notify" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notify():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#notify():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#notifyAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="notifyAll():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#notifyAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#notifySubscribers" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="notifySubscribers(currentContext:Option[scala.concurrent.ExecutionContext]):Unit" class="anchorToMember"></a><a id="notifySubscribers(Option[ExecutionContext]):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#notifySubscribers(currentContext:Option[scala.concurrent.ExecutionContext]):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifySubscribers</span><span class="params">(<span name="currentContext">currentContext: <span name="scala.Option" class="extype">Option</span>[<span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span>] = <span class="symbol">None</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Notifies the subscribers that the value of the signal has changed.</p><div class="fullcomment"><div class="comment cmt"><p>Notifies the subscribers that the value of the signal has changed.
</p></div><dl class="paramcmts block"><dt class="param">currentContext</dt><dd class="cmt"><p>The execution context on which the subscriber functions will be called if subscriptions don't specify otherwise (optional).</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource#notifySubscribers" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="notifySubscribers(call:S=&gt;Unit):Unit" class="anchorToMember"></a><a id="notifySubscribers((SignalSubscriber)=&gt;Unit):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#notifySubscribers(call:S=&gt;Unit):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">notifySubscribers</span><span class="params">(<span name="call">call: (<span name="com.wire.signals.Signal.SignalSubscriber" class="extype">SignalSubscriber</span>) =&gt; <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">The class which implements this <code>EventRelay</code> can use this method to notify all the subscribers that a new event
arrived.</p><div class="fullcomment"><div class="comment cmt"><p>The class which implements this <code>EventRelay</code> can use this method to notify all the subscribers that a new event
arrived.
</p></div><dl class="paramcmts block"><dt class="param">call</dt><dd class="cmt"><p>A function that will perform some action on each subscriber</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#on" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="on(ec:scala.concurrent.ExecutionContext)(body:V=&gt;Unit)(impliciteventContext:com.wire.signals.EventContext):com.wire.signals.Subscription" class="anchorToMember"></a><a id="on(ExecutionContext)((V)=&gt;Unit)(EventContext):Subscription" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#on(ec:scala.concurrent.ExecutionContext)(body:V=&gt;Unit)(impliciteventContext:com.wire.signals.EventContext):com.wire.signals.Subscription" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">on</span><span class="params">(<span name="ec">ec: <span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span></span>)</span><span class="params">(<span name="body">body: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="eventContext">eventContext: <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> = <span class="symbol"><span class="name"><a href="EventContext$.html">EventContext.Global</a></span></span></span>)</span><span class="result">: <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a></span></span><p class="shortcomment cmt">Registers a subscriber in a specified execution context and returns the subscription.</p><div class="fullcomment"><div class="comment cmt"><p>Registers a subscriber in a specified execution context and returns the subscription. An optional event context can also
be provided by the user for managing the subscription instead of doing it manually. When the value of the signal changes,
the subscriber function will be called in the given execution context instead of the one of the publisher.
</p></div><dl class="paramcmts block"><dt class="param">ec</dt><dd class="cmt"><p>An <code>ExecutionContext</code> in which the body function will be executed.</p></dd><dt class="param">body</dt><dd class="cmt"><p>A function which is called initially, when registered in the signal,
            and then every time the value of the signal changes.</p></dd><dt class="param">eventContext</dt><dd class="cmt"><p>An <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> which will register the <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a> for further management (optional)</p></dd><dt>returns</dt><dd class="cmt"><p>A <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a> representing the created connection between the signal and the body function</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a> → <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#onChanged" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onChanged:com.wire.signals.EventStream[V]" class="anchorToMember"></a><a id="onChanged:EventStream[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#onChanged:com.wire.signals.EventStream[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">onChanged</span><span class="result">: <a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">An event stream where each event is a new value of the signal.</p><div class="fullcomment"><div class="comment cmt"><p>An event stream where each event is a new value of the signal.
Every time the value of the signal changes - actually changes to another value - the new value will be published in this stream.
The events in the stream are guaranteed to differ. It's not possible to get two equal events one after another.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#onCurrent" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onCurrent(body:V=&gt;Unit)(impliciteventContext:com.wire.signals.EventContext):com.wire.signals.Subscription" class="anchorToMember"></a><a id="onCurrent((V)=&gt;Unit)(EventContext):Subscription" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#onCurrent(body:V=&gt;Unit)(impliciteventContext:com.wire.signals.EventContext):com.wire.signals.Subscription" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onCurrent</span><span class="params">(<span name="body">body: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="eventContext">eventContext: <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> = <span class="symbol"><span class="name"><a href="EventContext$.html">EventContext.Global</a></span></span></span>)</span><span class="result">: <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a></span></span><p class="shortcomment cmt">Registers a subscriber which will always be called in the same execution context in which the value of the signal was changed.</p><div class="fullcomment"><div class="comment cmt"><p>Registers a subscriber which will always be called in the same execution context in which the value of the signal was changed.
An optional event context can be provided by the user for managing the subscription instead of doing it manually.
</p></div><dl class="paramcmts block"><dt class="param">body</dt><dd class="cmt"><p>A function which is called initially, when registered in the signal,
            and then every time the value of the signal changes.</p></dd><dt class="param">eventContext</dt><dd class="cmt"><p>An <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> which will register the <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a> for further management (optional)</p></dd><dt>returns</dt><dd class="cmt"><p>A <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a> representing the created connection between the signal and the body function</p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a> → <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd><dt>See also</dt><dd><span class="cmt"><p><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#onFalse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onFalse(implicitev:V=:=Boolean):scala.concurrent.Future[Unit]" class="anchorToMember"></a><a id="onFalse(=:=[V,Boolean]):Future[Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#onFalse(implicitev:V=:=Boolean):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onFalse</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.=:=" class="extype">=:=</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="scala.Boolean" class="extype">Boolean</span>]</span>)</span><span class="result">: <span name="scala.concurrent.Future" class="extype">Future</span>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">Assuming that the value of the signal can be interpreted as a boolean, this method returns a future
of type <code>Unit</code> which will finish with success when the value of the original signal is false.</p><div class="fullcomment"><div class="comment cmt"><p>Assuming that the value of the signal can be interpreted as a boolean, this method returns a future
of type <code>Unit</code> which will finish with success when the value of the original signal is false.</p><p><code><code><code>
val signal = Signal[Int](2)
signal.map(_ % 2 == 0).onFalse.foreach { _ =&gt; println("This is the first time the value of the signal is odd") }
<code><code><code>
</code></code></code></code></code></code></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A new future which finishes either immediately or as soon as the value of the original signal is false.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#onPartialUpdate" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onPartialUpdate[Z](select:V=&gt;Z):com.wire.signals.Signal[V]" class="anchorToMember"></a><a id="onPartialUpdate[Z]((V)=&gt;Z):Signal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#onPartialUpdate[Z](select:V=&gt;Z):com.wire.signals.Signal[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onPartialUpdate</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="select">select: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="com.wire.signals.Signal.onPartialUpdate.Z" class="extype">Z</span></span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">Creates a new signal of the same value type which changes its value to the changed value of the parent signal only if
the given <code>select</code> function returns different results for the old and the new value.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new signal of the same value type which changes its value to the changed value of the parent signal only if
the given <code>select</code> function returns different results for the old and the new value. If the results of the <code>select</code>
functions are equal, then even if the new value of the original signal is actually different from the old one, the value
of the new signal stays the same.</p><p>Consider the following example:
<code><code><code>
val parent = Signal[Int](3)
val oddEvenSwitch = parent.onPartialUpdate { _ % 2 == 0 }
oddEvenSwitch.foreach { _ =&gt; println(s"The value switched between odd and even") }
<code><code><code>
Here, the value of </code>oddEvenSwitch</code> will update only if the new value is even if the old one was odd and vice versa.
So, if we publish new odd values to </code>parent</code> (1, 5, 9, 7, ...) the value of </code>oddEvenSwitch</code> will stay at 3. Only
when we publish an even number to <code>parent</code> (say, 2), the value <code>oddEventSwitch</code> will change. And from now on it will
stay like that until we publish an odd number to the parent.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The type of the value returned by the <code>select</code> function.</p></dd><dt class="param">select</dt><dd class="cmt"><p>A function mapping from the current value of the original signal to another value which will be used
              for checking if the new signal should update.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal of the same value type as this one, which updates only if the <code>select</code> function gives different
        results for the old and the new value of the parent signal.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#onTrue" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onTrue(implicitev:V=:=Boolean):scala.concurrent.Future[Unit]" class="anchorToMember"></a><a id="onTrue(=:=[V,Boolean]):Future[Unit]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#onTrue(implicitev:V=:=Boolean):scala.concurrent.Future[Unit]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onTrue</span><span class="params">(<span class="implicit">implicit </span><span name="ev">ev: <span name="scala.=:=" class="extype">=:=</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="scala.Boolean" class="extype">Boolean</span>]</span>)</span><span class="result">: <span name="scala.concurrent.Future" class="extype">Future</span>[<span name="scala.Unit" class="extype">Unit</span>]</span></span><p class="shortcomment cmt">Assuming that the value of the signal can be interpreted as a boolean, this method returns a future
of type <code>Unit</code> which will finish with success when the value of the original signal is true.</p><div class="fullcomment"><div class="comment cmt"><p>Assuming that the value of the signal can be interpreted as a boolean, this method returns a future
of type <code>Unit</code> which will finish with success when the value of the original signal is true.</p><p><code><code><code>
val signal = Signal[Int](3)
signal.map(_ % 2 == 0).onTrue.foreach { _ =&gt; println("This is the first time the value of the signal is even") }
<code><code><code>
</code></code></code></code></code></code></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A new future which finishes either immediately or as soon as the value of the original signal is true.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#onUnwire" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="onUnwire():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#onUnwire():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onUnwire</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">This method will be called on removing the last subscription if <code>disableAutoWiring</code> was not called.</p><div class="fullcomment"><div class="comment cmt"><p>This method will be called on removing the last subscription if <code>disableAutoWiring</code> was not called.
</p></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a> → <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#onUpdated" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="onUpdated:com.wire.signals.EventStream[(Option[V],V)]" class="anchorToMember"></a><a id="onUpdated:EventStream[(Option[V],V)]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#onUpdated:com.wire.signals.EventStream[(Option[V],V)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">lazy val</span></span> <span class="symbol"><span class="name">onUpdated</span><span class="result">: <a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a>[(<span name="scala.Option" class="extype">Option</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>], <span name="com.wire.signals.Signal.V" class="extype">V</span>)]</span></span><p class="shortcomment cmt">An event stream where each event is a tuple of the old and the new value of the signal.</p><div class="fullcomment"><div class="comment cmt"><p>An event stream where each event is a tuple of the old and the new value of the signal.
Every time the value of the signal changes - actually changes to another value - the new value will be published in this stream,
together with the old value which you can use to check what exactly changed. The old value is wrapped in an <code>Option</code>: if the signal
was previously empty, the old value will be <code>None</code> otherwise it will be <code>Some[V]</code>.
The values are guaranteed to differ, i.e. if you get a tuple <code>(Some(oldValue), newValue)</code> then <code>oldValue != newValue</code>.
</p></div></div></li><li class="indented0 " name="com.wire.signals.Signal#onWire" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="onWire():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#onWire():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">onWire</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a> → <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd><dt>To do</dt><dd><span class="cmt"><p>This is an old comment to this method. Consider writing the same in a simpler way.
If this signal is computed from sources that change their value via a side effect (such as signals) and is not
informed of those changes while unwired (e.g. because this signal removes itself from the sources' children
lists in #onUnwire), it is mandatory to update/recompute this signal's value from the sources in #onWire, since
a dispatch always happens after #onWire. This is true even if the source values themselves did not change, for the
recomputation in itself may rely on side effects.
This also implies that a signal should never #dispatch in #onWire because that will happen anyway immediately
afterwards in #subscribe.</p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#orElse" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="orElse(fallback:com.wire.signals.Signal[V]):com.wire.signals.Signal[V]" class="anchorToMember"></a><a id="orElse(Signal[V]):Signal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#orElse(fallback:com.wire.signals.Signal[V]):com.wire.signals.Signal[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">orElse</span><span class="params">(<span name="fallback">fallback: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">Creates a version of this signal which, if the parent signal becomes empty, temporarily uses the value of the given
<code>fallback</code> signal.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a version of this signal which, if the parent signal becomes empty, temporarily uses the value of the given
<code>fallback</code> signal. The moment the parent signal is set to a new value again, the new signal switches back to it.
Only when both signals are empty, the new signal will become empty too.
</p></div><dl class="paramcmts block"><dt class="param">fallback</dt><dd class="cmt"><p>Another signal of the same value type.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal of the same value type.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#pipeTo" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="pipeTo(sourceSignal:com.wire.signals.SourceSignal[V])(implicitec:com.wire.signals.EventContext):com.wire.signals.Subscription" class="anchorToMember"></a><a id="pipeTo(SourceSignal[V])(EventContext):Subscription" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#pipeTo(sourceSignal:com.wire.signals.SourceSignal[V])(implicitec:com.wire.signals.EventContext):com.wire.signals.Subscription" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">pipeTo</span><span class="params">(<span name="sourceSignal">sourceSignal: <a href="SourceSignal.html" name="com.wire.signals.SourceSignal" id="com.wire.signals.SourceSignal" class="extype">SourceSignal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ec">ec: <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> = <span class="symbol"><span class="name"><a href="EventContext$.html">EventContext.Global</a></span></span></span>)</span><span class="result">: <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a></span></span><p class="shortcomment cmt">A shorthand for registering a subscriber function in this signal which only purpose is to publish changes to the value
of this signal in another <a href="SourceSignal.html" name="com.wire.signals.SourceSignal" id="com.wire.signals.SourceSignal" class="extype">SourceSignal</a>.</p><div class="fullcomment"><div class="comment cmt"><p>A shorthand for registering a subscriber function in this signal which only purpose is to publish changes to the value
of this signal in another <a href="SourceSignal.html" name="com.wire.signals.SourceSignal" id="com.wire.signals.SourceSignal" class="extype">SourceSignal</a>. The subscriber function will be called in the execution context of the
original publisher.
</p></div><dl class="paramcmts block"><dt class="param">sourceSignal</dt><dd class="cmt"><p>he signal in which changes to the value of this signal will be published.</p></dd><dt class="param">ec</dt><dd class="cmt"><p>An <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> which can be used to manage the subscription (optional).</p></dd><dt>returns</dt><dd class="cmt"><p>A new <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a> to this signal.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="SourceSignal.html" name="com.wire.signals.SourceSignal" id="com.wire.signals.SourceSignal" class="extype">SourceSignal</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#publish" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="publish(value:V,currentContext:scala.concurrent.ExecutionContext):Unit" class="anchorToMember"></a><a id="publish(V,ExecutionContext):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#publish(value:V,currentContext:scala.concurrent.ExecutionContext):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">publish</span><span class="params">(<span name="value">value: <span name="com.wire.signals.Signal.V" class="extype">V</span></span>, <span name="currentContext">currentContext: <span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Sets the value of the signal to the given value.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of the signal to the given value. Notifies the subscribers if the value actually changes.
if the subscription specify the execution context, that execution context will be used to execute the subscriber
function, and only if not, the context given in the <code>publish</code> method will be used.
</p></div><dl class="paramcmts block"><dt class="param">value</dt><dd class="cmt"><p>The new value of the signal.</p></dd><dt class="param">currentContext</dt><dd class="cmt"><p>The execution context that will be used to call the subscriber function if the subscription
                      does not say otherwise.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#publish" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="publish(value:V):Unit" class="anchorToMember"></a><a id="publish(V):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#publish(value:V):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">publish</span><span class="params">(<span name="value">value: <span name="com.wire.signals.Signal.V" class="extype">V</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Sets the value of the signal to the given value.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of the signal to the given value. Notifies the subscribers if the value actually changes.
</p></div><dl class="paramcmts block"><dt class="param">value</dt><dd class="cmt"><p>The new value of the signal.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#scan" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="scan[Z](zero:Z)(f:(Z,V)=&gt;Z):com.wire.signals.Signal[Z]" class="anchorToMember"></a><a id="scan[Z](Z)((Z,V)=&gt;Z):Signal[Z]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#scan[Z](zero:Z)(f:(Z,V)=&gt;Z):com.wire.signals.Signal[Z]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">scan</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="zero">zero: <span name="com.wire.signals.Signal.scan.Z" class="extype">Z</span></span>)</span><span class="params">(<span name="f">f: (<span name="com.wire.signals.Signal.scan.Z" class="extype">Z</span>, <span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="com.wire.signals.Signal.scan.Z" class="extype">Z</span></span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.scan.Z" class="extype">Z</span>]</span></span><p class="shortcomment cmt">Creates a new signal with the value type <code>Z</code> where the change in the value is the result of applying a function
which combines the previous value of type <code>Z</code> with the changed value of the type <code>V</code> of the parent signal.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new signal with the value type <code>Z</code> where the change in the value is the result of applying a function
which combines the previous value of type <code>Z</code> with the changed value of the type <code>V</code> of the parent signal.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The value type of the new signal.</p></dd><dt class="param">zero</dt><dd class="cmt"><p>The initial value of the new signal.</p></dd><dt class="param">f</dt><dd class="cmt"><p>The function which combines the current value of the new signal with the new, changed value of the parent (this) signal
         to produce a new value for the new signal (might be the same as the old one and then subscribers won't be notified).</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal with the value of the type <code>Z</code>.</p></dd></dl><dl class="attributes block"><dt>To do</dt><dd><span class="cmt"><p>Test if it really works like that, the code is a bit complicated.</p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#set" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="set(v:Option[V],currentContext:Option[scala.concurrent.ExecutionContext]):Boolean" class="anchorToMember"></a><a id="set(Option[V],Option[ExecutionContext]):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#set(v:Option[V],currentContext:Option[scala.concurrent.ExecutionContext]):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">set</span><span class="params">(<span name="v">v: <span name="scala.Option" class="extype">Option</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span>, <span name="currentContext">currentContext: <span name="scala.Option" class="extype">Option</span>[<span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span>] = <span class="symbol">None</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Sets the value of the signal to the new one.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the value of the signal to the new one.
The new value is an option of the value type. If the result is <code>None</code> the signal will become empty until the next update.
The subscribers will be notified of the update only if the new value is different from the current one. If yes, we will try to
call them on the given execution context, but only if the subscriptions do not specify otherwise.
</p></div><dl class="paramcmts block"><dt class="param">v</dt><dd class="cmt"><p>The new value of the signal.</p></dd><dt class="param">currentContext</dt><dd class="cmt"><p>The execution context on which the subscriber functions will be called if subscriptions don't specify otherwise (optional).</p></dd><dt>returns</dt><dd class="cmt"><p>true if the new value is different from the old one and so a change actually happens and the subscribers will be notified,
        false if the new value is the same as the old one.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="index.html" name="com.wire.signals" id="com.wire.signals" class="extype">signals</a>] </dd><dt>To do</dt><dd><span class="cmt"><p>Check why we synchronize in <code>update</code> but not here. It clearly works: tests fail if we synchronize this method. I just want to know why.</p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource#subscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="subscribe(subscriber:S):Unit" class="anchorToMember"></a><a id="subscribe(SignalSubscriber):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#subscribe(subscriber:S):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">subscribe</span><span class="params">(<span name="subscriber">subscriber: <span name="com.wire.signals.Signal.SignalSubscriber" class="extype">SignalSubscriber</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Adds a new subscriber instance.</p><div class="fullcomment"><div class="comment cmt"><p>Adds a new subscriber instance. The implementing class should handle notifying this subscriber
when a new event arrives. If this is the first subscriber, and <code>disableAutowiring</code> wasn't called previous,
this will trigger a call to <code>onWire</code>.
</p></div><dl class="paramcmts block"><dt class="param">subscriber</dt><dd class="cmt"><p>An instance of a subscriber class, known to the class implementing this <code>EventRelay</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#synchronized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="synchronized[T0](x$1:=&gt;T0):T0" class="anchorToMember"></a><a id="synchronized[T0](=&gt;T0):T0" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#synchronized[T0](x$1:=&gt;T0):T0" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: =&gt; <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span>)</span><span class="result">: <span name="java.lang.AnyRef.synchronized.T0" class="extype">T0</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#throttle" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="throttle(delay:scala.concurrent.duration.FiniteDuration):com.wire.signals.Signal[V]" class="anchorToMember"></a><a id="throttle(FiniteDuration):Signal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#throttle(delay:scala.concurrent.duration.FiniteDuration):com.wire.signals.Signal[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">throttle</span><span class="params">(<span name="delay">delay: <span name="scala.concurrent.duration.FiniteDuration" class="extype">FiniteDuration</span></span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">Creates a throttled version of this signal which updates no more often than once during the given time interval.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a throttled version of this signal which updates no more often than once during the given time interval.
If changes to the value of the parent signal happen more often, some of them will be ignored.
</p></div><dl class="paramcmts block"><dt class="param">delay</dt><dd class="cmt"><p>The time interval used for throttling.</p></dd><dt>returns</dt><dd class="cmt"><p>A new throttled signal of the same value type as the parent.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="ThrottledSignal.html" name="com.wire.signals.ThrottledSignal" id="com.wire.signals.ThrottledSignal" class="extype">ThrottledSignal</a></p></span></dd></dl></div></li><li class="indented0 " name="scala.AnyRef#toString" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="toString():String" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#toString():String" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">toString</span><span class="params">()</span><span class="result">: <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#java.lang.String" name="java.lang.String" id="java.lang.String" class="extype">String</a></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource#unsubscribe" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unsubscribe(subscriber:S):Unit" class="anchorToMember"></a><a id="unsubscribe(SignalSubscriber):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#unsubscribe(subscriber:S):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unsubscribe</span><span class="params">(<span name="subscriber">subscriber: <span name="com.wire.signals.Signal.SignalSubscriber" class="extype">SignalSubscriber</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Removes a previously registered subscriber instance.</p><div class="fullcomment"><div class="comment cmt"><p>Removes a previously registered subscriber instance.
If this is the last subscriber, and <code>disableAutowiring</code> wasn't called previously, this will trigger a call to <code>onUnwire</code>.
</p></div><dl class="paramcmts block"><dt class="param">subscriber</dt><dd class="cmt"><p>An instance of a subscriber class, known to the class implementing this <code>EventRelay</code></p></dd></dl><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource#unsubscribeAll" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="unsubscribeAll():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#unsubscribeAll():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">unsubscribeAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><p class="shortcomment cmt">Empties the set of subscribers and calls <code>unWire</code> if <code>disableAutowiring</code> wasn't called before.</p><div class="fullcomment"><div class="comment cmt"><p>Empties the set of subscribers and calls <code>unWire</code> if <code>disableAutowiring</code> wasn't called before.
</p></div><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#update" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="update(f:Option[V]=&gt;Option[V],currentContext:Option[scala.concurrent.ExecutionContext]):Boolean" class="anchorToMember"></a><a id="update((Option[V])=&gt;Option[V],Option[ExecutionContext]):Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#update(f:Option[V]=&gt;Option[V],currentContext:Option[scala.concurrent.ExecutionContext]):Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">def</span></span> <span class="symbol"><span class="name">update</span><span class="params">(<span name="f">f: (<span name="scala.Option" class="extype">Option</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]) =&gt; <span name="scala.Option" class="extype">Option</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span>, <span name="currentContext">currentContext: <span name="scala.Option" class="extype">Option</span>[<span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span>] = <span class="symbol">None</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><p class="shortcomment cmt">Updates the current value of the signal by applying a given function to it.</p><div class="fullcomment"><div class="comment cmt"><p>Updates the current value of the signal by applying a given function to it.
The function should return an option of the value type. If the result is <code>None</code> the signal will become empty until the next update.
The subscribers will be notified of the update only if the new value is different from the current one. If yes, we will try to
call them on the given execution context, but only if the subscriptions do not specify otherwise.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>The function used to update the value of the signal.</p></dd><dt class="param">currentContext</dt><dd class="cmt"><p>The execution context on which the subscriber functions will be called if subscriptions don't specify otherwise (optional).</p></dd><dt>returns</dt><dd class="cmt"><p>true if the update actually happened and subscribers will be notified, false if the new value is the same as the old one.</p></dd></dl><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="index.html" name="com.wire.signals" id="com.wire.signals" class="extype">signals</a>] </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#value" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="prt"><a id="value:Option[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#value:Option[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">var</span></span> <span class="symbol"><span class="name">value</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><div class="fullcomment"><dl class="attributes block"><dt>Attributes</dt><dd>protected[<a href="index.html" name="com.wire.signals" id="com.wire.signals" class="extype">signals</a>] </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait():Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#wait():Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long,x$2:Int):Unit" class="anchorToMember"></a><a id="wait(Long,Int):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#wait(x$1:Long,x$2:Int):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> </dd></dl></div></li><li class="indented0 " name="scala.AnyRef#wait" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wait(x$1:Long):Unit" class="anchorToMember"></a><a id="wait(Long):Unit" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#wait(x$1:Long):Unit" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd><span class="name">@throws</span><span class="args">(<span><span class="defval">classOf[java.lang.InterruptedException]</span></span>)</span> <span class="name">@native</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource#wired" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wired:Boolean" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#wired:Boolean" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">wired</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></dd><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#withFilter" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="withFilter(f:V=&gt;Boolean):com.wire.signals.Signal[V]" class="anchorToMember"></a><a id="withFilter((V)=&gt;Boolean):Signal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#withFilter(f:V=&gt;Boolean):com.wire.signals.Signal[V]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">withFilter</span><span class="params">(<span name="f">f: (<span name="com.wire.signals.Signal.V" class="extype">V</span>) =&gt; <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">An alias for <code>filter</code> used in the for/yield notation.</p><div class="fullcomment"><div class="comment cmt"><p>An alias for <code>filter</code> used in the for/yield notation.</p><p>This can be useful for more readable chains of asynchronous computations where at some point we want to wait until
some condition is fulfilled:
<code><code><code>
val resultSignal = for {
 a    &lt;- signalA
 b    &lt;- signalB
 true &lt;- checkCondition(a, b)
 c    &lt;- signalC
} yield c
<code><code><code>
Here, </code>resultSignal</code> will be updated to the value of </code>signalC</code> only if the current values of </code>signalA</code> and <code>signalB</code> fulfill
the condition. If the check fails, <code>resultSignal</code> will become empty until <code>signalA</code> or <code>signalB</code> changes its value and the new
pair fulfills the condition.
</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#zip" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="zip[Z](other:com.wire.signals.Signal[Z]):com.wire.signals.Signal[(V,Z)]" class="anchorToMember"></a><a id="zip[Z](Signal[Z]):Signal[(V,Z)]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#zip[Z](other:com.wire.signals.Signal[Z]):com.wire.signals.Signal[(V,Z)]" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name">zip</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="other">other: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.Signal.zip.Z" class="extype">Z</span>]</span>)</span><span class="result">: <a href="" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[(<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="com.wire.signals.Signal.zip.Z" class="extype">Z</span>)]</span></span><p class="shortcomment cmt">Zips this signal with the given one.</p><div class="fullcomment"><div class="comment cmt"><p>Zips this signal with the given one.
</p></div><dl class="paramcmts block"><dt class="tparam">Z</dt><dd class="cmt"><p>The type of the values of the other signal.</p></dd><dt class="param">other</dt><dd class="cmt"><p>The other signal with values of the same or a different type.</p></dd><dt>returns</dt><dd class="cmt"><p>A new signal with values being tuples of the value of this signal and the other one.
        The value of the other signal will be updated every time this or the other signal's value is updated.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal#|" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="|(sourceSignal:com.wire.signals.SourceSignal[V])(implicitec:com.wire.signals.EventContext):com.wire.signals.Subscription" class="anchorToMember"></a><a id="|(SourceSignal[V])(EventContext):Subscription" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html#|(sourceSignal:com.wire.signals.SourceSignal[V])(implicitec:com.wire.signals.EventContext):com.wire.signals.Subscription" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">def</span></span> <span class="symbol"><span class="name" title="gt4s: $bar">|</span><span class="params">(<span name="sourceSignal">sourceSignal: <a href="SourceSignal.html" name="com.wire.signals.SourceSignal" id="com.wire.signals.SourceSignal" class="extype">SourceSignal</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="ec">ec: <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> = <span class="symbol"><span class="name"><a href="EventContext$.html">EventContext.Global</a></span></span></span>)</span><span class="result">: <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a></span></span><p class="shortcomment cmt">An alias for <code>pipeTo</code>.</p><div class="fullcomment"><div class="comment cmt"><p>An alias for <code>pipeTo</code>.</p></div><dl class="attributes block"><dt>Annotations</dt><dd><span class="name">@inline</span><span class="args">()</span> </dd></dl></div></li></ol></div></div><div id="inheritedMembers"><div name="com.wire.signals.EventSource" class="parent"><h3>Inherited from <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="com.wire.signals.Signal.SignalSubscriber" class="extype">SignalSubscriber</span>]</h3></div><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
