<!DOCTYPE html ><html><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/><title></title><meta content="" name="description"/><meta content="" name="keywords"/><meta http-equiv="content-type" content="text/html; charset=UTF-8"/><link href="../../../lib/index.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet"/><link href="../../../lib/print.css" media="print" type="text/css" rel="stylesheet"/><link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css"/><script type="text/javascript" src="../../../lib/jquery.min.js"></script><script type="text/javascript" src="../../../lib/index.js"></script><script type="text/javascript" src="../../../index.js"></script><script type="text/javascript" src="../../../lib/scheduler.js"></script><script type="text/javascript" src="../../../lib/template.js"></script><script type="text/javascript">/* this variable can be used by the JS to determine the path to the root document */
var toRoot = '../../../';</script></head><body><div id="search"><span id="doc-title"><span id="doc-version"></span></span> <span class="close-results"><span class="left">&lt;</span> Back</span><div id="textfilter"><span class="input"><input autocapitalize="none" placeholder="Search" id="index-input" type="text" accesskey="/"/><i class="clear material-icons"></i><i id="search-icon" class="material-icons"></i></span></div></div><div id="search-results"><div id="search-progress"><div id="progress-fill"></div></div><div id="results-content"><div id="entity-results"></div><div id="member-results"></div></div></div><div id="content-scroll-container" style="-webkit-overflow-scrolling: touch;"><div id="content-container" style="-webkit-overflow-scrolling: touch;"><div id="subpackage-spacer"><div id="packages"><h1>Packages</h1><ul><li class="indented0 " name="_root_.root" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="_root_" class="anchorToMember"></a><a id="root:_root_" class="anchorToMember"></a> <span class="permalink"><a href="../../../index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../../index.html" title=""><span class="name">root</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented1 " name="_root_.com" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="com" class="anchorToMember"></a><a id="com:com" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../../index.html" title=""><span class="name">com</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../../index.html" name="_root_" id="_root_" class="extype">root</a></dd></dl></div></li><li class="indented2 " name="com.wire" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="wire" class="anchorToMember"></a><a id="wire:wire" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="../index.html" title=""><span class="name">wire</span></a></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../../index.html" name="com" id="com" class="extype">com</a></dd></dl></div></li><li class="indented3 current" name="com.wire.signals" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="signals" class="anchorToMember"></a><a id="signals:signals" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">signals</span></span><div class="fullcomment"><dl class="attributes block"><dt>Definition Classes</dt><dd><a href="../index.html" name="com.wire" id="com.wire" class="extype">wire</a></dd></dl></div></li><li class="indented4 " name="com.wire.signals.ui" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ui" class="anchorToMember"></a><a id="ui:ui" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ui/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="ui/index.html" title=""><span class="name">ui</span></a></span></li><li class="current-entities indented3"><a href="AggregatingSignal$.html" title="" class="object"></a> <a href="AggregatingSignal.html" title="A signal which initializes its value by executing the loader future and then updates the value by composition of the previous value and an event published in the associated source stream." class="class"></a><a href="AggregatingSignal.html" title="A signal which initializes its value by executing the loader future and then updates the value by composition of the previous value and an event published in the associated source stream.">AggregatingSignal</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="BaseEventContext.html" title="" class="class"></a><a href="BaseEventContext.html" title="">BaseEventContext</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="BaseSubscription.html" title="Provides the default implementation of the Subscription trait." class="class"></a><a href="BaseSubscription.html" title="Provides the default implementation of the Subscription trait.">BaseSubscription</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Cancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually cancellable." class="class"></a><a href="Cancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually cancellable.">Cancellable</a></li><li class="current-entities indented3"><a href="CancellableFuture$.html" title="CancellableFuture is an object that for all practical uses works like a future but enables the user to cancel the operation." class="object"></a> <a href="CancellableFuture.html" title="CancellableFuture is an object that for all practical uses works like a future but enables the user to cancel the operation." class="class"></a><a href="CancellableFuture.html" title="CancellableFuture is an object that for all practical uses works like a future but enables the user to cancel the operation.">CancellableFuture</a></li><li class="current-entities indented3"><a href="ConstSignal$.html" title="" class="object"></a> <a href="ConstSignal.html" title="A signal holding an immutable value." class="class"></a><a href="ConstSignal.html" title="A signal holding an immutable value.">ConstSignal</a></li><li class="current-entities indented3"><a href="DispatchQueue$.html" title="" class="object"></a> <a href="DispatchQueue.html" title="A thin wrapper over Scala's ExecutionContext allowing us to differentiate between the default execution context which tries to run asynchronously as many tasks as possible, and limited execution contexts, allowed to run only up to a given number of tasks at once." class="trait"></a><a href="DispatchQueue.html" title="A thin wrapper over Scala's ExecutionContext allowing us to differentiate between the default execution context which tries to run asynchronously as many tasks as possible, and limited execution contexts, allowed to run only up to a given number of tasks at once.">DispatchQueue</a></li><li class="current-entities indented3"><a href="EventContext$.html" title="" class="object"></a> <a href="EventContext.html" title="When you subscribe to an EventSource in return you receive a Subscription." class="trait"></a><a href="EventContext.html" title="When you subscribe to an EventSource in return you receive a Subscription.">EventContext</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="EventSource.html" title="" class="class"></a><a href="EventSource.html" title="">EventSource</a></li><li class="current-entities indented3"><a href="EventStream$.html" title="" class="object"></a> <a href="EventStream.html" title="An event stream of type E dispatches events (of type E) to all functions of type (E) =&gt; Unit which were registered in the event stream as its subscribers." class="class"></a><a href="EventStream.html" title="An event stream of type E dispatches events (of type E) to all functions of type (E) =&gt; Unit which were registered in the event stream as its subscribers.">EventStream</a></li><li class="current-entities indented3"><a href="EventStreamWithAuxSignal$.html" title="" class="object"></a> <a href="EventStreamWithAuxSignal.html" title="An event stream coupled with an auxiliary signal." class="class"></a><a href="EventStreamWithAuxSignal.html" title="An event stream coupled with an auxiliary signal.">EventStreamWithAuxSignal</a></li><li class="current-entities indented3"><a href="LimitedDispatchQueue$.html" title="" class="object"></a> <a href="LimitedDispatchQueue.html" title="A dispatch queue limiting number of concurrently executing tasks." class="class"></a><a href="LimitedDispatchQueue.html" title="A dispatch queue limiting number of concurrently executing tasks.">LimitedDispatchQueue</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="NoAutowiring.html" title="By default, a new signal is initialized lazily, i.e." class="trait"></a><a href="NoAutowiring.html" title="By default, a new signal is initialized lazily, i.e.">NoAutowiring</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ProxyEventStream.html" title="A superclass for all event streams which compose other event streams into one." class="class"></a><a href="ProxyEventStream.html" title="A superclass for all event streams which compose other event streams into one.">ProxyEventStream</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="ProxySignal.html" title="" class="class"></a><a href="ProxySignal.html" title="">ProxySignal</a></li><li class="current-entities indented3"><a href="RefreshingSignal$.html" title="" class="object"></a> <a href="RefreshingSignal.html" title="A signal which initializes its value by executing the loader cancellable future and then updates the value the same way every time a new refresh event is published in the associated event stream." class="class"></a><a href="RefreshingSignal.html" title="A signal which initializes its value by executing the loader cancellable future and then updates the value the same way every time a new refresh event is published in the associated event stream.">RefreshingSignal</a></li><li class="current-entities indented3"><a href="SerialDispatchQueue$.html" title="" class="object"></a> <a href="SerialDispatchQueue.html" title="A special case of a limited dispatch queue which allows for only one task to be executed at once." class="class"></a><a href="SerialDispatchQueue.html" title="A special case of a limited dispatch queue which allows for only one task to be executed at once.">SerialDispatchQueue</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Serialized$.html" title="A utility object for serializing futures." class="object"></a><a href="Serialized$.html" title="A utility object for serializing futures.">Serialized</a></li><li class="current-entities indented3"><a href="Signal$.html" title="" class="object"></a> <a href="Signal.html" title="A signal is an event stream with a cache." class="class"></a><a href="Signal.html" title="A signal is an event stream with a cache.">Signal</a></li><li class="current-entities indented3"><a href="SourceSignal$.html" title="" class="object"></a> <a href="SourceSignal.html" title="The usual entry point for publishing values in signals." class="class"></a><a href="SourceSignal.html" title="The usual entry point for publishing values in signals.">SourceSignal</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="SourceStream.html" title="The usual entry point for publishing events." class="class"></a><a href="SourceStream.html" title="The usual entry point for publishing events.">SourceStream</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Subscription.html" title="When you add a new subscriber to your EventStream or Signal, in return you get a Subscription." class="trait"></a><a href="Subscription.html" title="When you add a new subscriber to your EventStream or Signal, in return you get a Subscription.">Subscription</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Threading$.html" title="Use Threading to set up the default execution context which will be later used as the parent for other dispatch queues and to run cancellable futures, event streams, and signals, if no other execution context is provided." class="object"></a><a href="Threading$.html" title="Use Threading to set up the default execution context which will be later used as the parent for other dispatch queues and to run cancellable futures, event streams, and signals, if no other execution context is provided.">Threading</a></li><li class="current-entities indented3"><a href="ThrottledSignal$.html" title="" class="object"></a> <a href="ThrottledSignal.html" title="A signal which publishes changes of its parent signal but no more often than once during a given time interval." class="class"></a><a href="ThrottledSignal.html" title="A signal which publishes changes of its parent signal but no more often than once during a given time interval.">ThrottledSignal</a></li><li class="current-entities indented3"><span class="separator"></span> <a href="Uncancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually **un**cancellable." class="class"></a><a href="Uncancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually **un**cancellable.">Uncancellable</a></li><li class="current-entities indented3"><a href="UnlimitedDispatchQueue$.html" title="" class="object"></a> <a href="UnlimitedDispatchQueue.html" title="A dispatch queue that simply passes all its tasks to its execution context." class="class"></a><a href="UnlimitedDispatchQueue.html" title="A dispatch queue that simply passes all its tasks to its execution context.">UnlimitedDispatchQueue</a></li></ul></div></div><div id="content"><body class="package value"><div id="definition"><div class="big-circle package">p</div><p id="owner"><a href="../../index.html" name="com" id="com" class="extype">com</a>.<a href="../index.html" name="com.wire" id="com.wire" class="extype">wire</a></p><h1>signals<span class="permalink"><a href="../../../com/wire/signals/index.html" title="Permalink"><i class="material-icons"></i></a></span></h1></div><h4 id="signature" class="signature"><span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><span class="name">signals</span></span></h4><div id="comment" class="fullcommenttop"><div class="toggleContainer"><div class="toggle block"><span>Linear Supertypes</span><div class="superTypes hiddenContent"><span name="scala.AnyRef" class="extype">AnyRef</span>, <span name="scala.Any" class="extype">Any</span></div></div></div></div><div id="mbrsel"><div class="toggle"></div><div id="memberfilter"><i class="material-icons arrow"></i><span class="input"><input placeholder="Filter all members" id="mbrsel-input" type="text" accesskey="/"/></span><i class="clear material-icons"></i></div><div id="filterby"><div id="order"><span class="filtertype">Ordering</span><ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By Inheritance</span></li></ol></div><div class="ancestors"><span class="filtertype">Inherited<br/></span><ol id="linearization"><li class="in" name="com.wire.signals"><span>signals</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li></ol></div><div class="ancestors"><span class="filtertype"></span><ol><li class="hideall out"><span>Hide All</span></li><li class="showall in"><span>Show All</span></li></ol></div><div id="visbl"><span class="filtertype">Visibility</span><ol><li class="public in"><span>Public</span></li><li class="protected out"><span>Protected</span></li></ol></div></div></div><div id="template"><div id="allMembers"><div id="packages" class="package members"><h3>Package Members</h3><ol><li class="indented0 " name="com.wire.signals.ui" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ui" class="anchorToMember"></a><a id="ui:ui" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ui/index.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">package</span></span> <span class="symbol"><a href="ui/index.html" title=""><span class="name">ui</span></a></span></li></ol></div><div id="types" class="types members"><h3>Type Members</h3><ol><li class="indented0 " name="com.wire.signals.AggregatingSignal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="AggregatingSignal[E,V]extendsSignal[V]withEventStream.EventSubscriber[E]" class="anchorToMember"></a><a id="AggregatingSignal[E,V]:AggregatingSignal[E,V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/AggregatingSignal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="AggregatingSignal.html" title="A signal which initializes its value by executing the loader future and then updates the value by composition of the previous value and an event published in the associated source stream."><span class="name">AggregatingSignal</span></a><span class="tparams">[<span name="E">E</span>, <span name="V">V</span>]</span><span class="result"> extends <a href="Signal.html" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.AggregatingSignal.V" class="extype">V</span>] with <span name="com.wire.signals.EventStream.EventSubscriber" class="extype">EventSubscriber</span>[<span name="com.wire.signals.AggregatingSignal.E" class="extype">E</span>]</span></span><p class="shortcomment cmt">A signal which initializes its value by executing the <code>loader</code> future and then updates the value by composition of
the previous value and an event published in the associated <code>source</code> stream.</p><div class="fullcomment"><div class="comment cmt"><p>A signal which initializes its value by executing the <code>loader</code> future and then updates the value by composition of
the previous value and an event published in the associated <code>source</code> stream.
You may think of it as a more performance-efficient version of <code>RefreshingSignal</code>, useful when the <code>loader</code>
requires heavy computations but an update between one value and another is simple in comparison. For example:
<code><code><code>
val loader: Future[ Vector[DBEntry] ] = fetchDBTableData()
val sourceStream: EventStream[DBEntry] = newDBTableEntryStream()
val updater: (Vector[DBEntry], DBEntry) =&gt; Vector[DBEntry] = { (table, newEntry) =&gt; table :+ newEntry }
val signal = new AggregatingSignal(loader, sourceStream, updater)
<code><code><code>
Here, the </code>loader</code> fetches the whole DB table, but if we know that the only change to that table is that new entries
can be added to it, we can avoid calling the </code>loader</code> every time the event comes. Instead, we can create the </code>updater</code>
function which will combine the current value of the signal (i.e. the in-memory cache of the DB table, created by
calling the <code>loader</code> only once, when the signal was initialized), with the new entry.
</p></div><dl class="paramcmts block"><dt class="tparam">E</dt><dd class="cmt"><p>The type of the update events.</p></dd><dt class="tparam">V</dt><dd class="cmt"><p>The type of the value held in the signal and the result of the <code>loader</code> execution.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="RefreshingSignal.html" name="com.wire.signals.RefreshingSignal" id="com.wire.signals.RefreshingSignal" class="extype">RefreshingSignal</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.BaseEventContext" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="BaseEventContextextendsEventContext" class="anchorToMember"></a><a id="BaseEventContext:BaseEventContext" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/BaseEventContext.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="BaseEventContext.html" title=""><span class="name">BaseEventContext</span></a><span class="result"> extends <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a></span></span></li><li class="indented0 " name="com.wire.signals.BaseSubscription" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="BaseSubscriptionextendsSubscription" class="anchorToMember"></a><a id="BaseSubscription:BaseSubscription" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/BaseSubscription.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="BaseSubscription.html" title="Provides the default implementation of the Subscription trait."><span class="name">BaseSubscription</span></a><span class="result"> extends <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a></span></span><p class="shortcomment cmt">Provides the default implementation of the <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a> trait.</p><div class="fullcomment"><div class="comment cmt"><p>Provides the default implementation of the <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a> trait.
Exposes two new abstract methods: <code>onSubscribe</code> and <code>onUnsubscribe</code>. A typical way to implement them is
to have a reference to the source of events which implements the <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a> trait and call <code>subscribe(this)</code>
on that source (where <code>this</code> is the subscription).</p><p>For examples:
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="Signal.html" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a></p></span><span class="cmt"><p><a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Cancellable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Cancellable[+T]extendsCancellableFuture[T]" class="anchorToMember"></a><a id="Cancellable[+T]:Cancellable[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Cancellable.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="Cancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually cancellable."><span class="name">Cancellable</span></a><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <a href="CancellableFuture.html" name="com.wire.signals.CancellableFuture" id="com.wire.signals.CancellableFuture" class="extype">CancellableFuture</a>[<span name="com.wire.signals.Cancellable.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">A subclass of <code>CancellableFuture</code> which represents a subset of cancellable futures which are actually cancellable.</p><div class="fullcomment"><div class="comment cmt"><p>A subclass of <code>CancellableFuture</code> which represents a subset of cancellable futures which are actually cancellable.
I know it means the name of the parent class is misleading, since not all cancellable futures are cancellable, but,
well, naming is a hard problem in computer science.
The reasoning here goes like this: An actually cancellable <code>CancellableFuture</code> is a wrapper over a <code>Promise</code>, not
a <code>Future</code>. We create a promise and try to fulfill it with the code given to us in one of the constructor methods.
If we succeed, the cancellable future will behave just as a regular one. But thanks to that we hold a promise,
we are able to cancel the ongoing execution of that piece of code by calling <code>tryFailure</code> on the promise.</p><p>However, in some situations cancelling will not be possible. One is of course that the future may already be completed -
with success or with failure (including that it might have been already cancelled). This is why the <code>cancel</code> method
returns a boolean - we can't be always 100% sure that calling it will actually cancel the future.</p><p>But there is also another possibility. Because of how ubiquitous futures are in the Scala standard library, it makes
sense to be able to wrap them in cancellable futures so that they can be used in the same code with the actually
cancellable futures. After all, if we're on the happy path, the two behave the same. The only difference appears
only when we try to cancel such a "cancellable" future - we don't have access to the parent promise of that future,
so we can't cancel it. Calling <code>cancel</code> on such a future will always return <code>false</code>, a callback registered with
<code>onCancel</code> will be ignored, etc.</p><p>The last case is an inverse of the second one: Sometimes we have an actually cancellable future but we want to
make sure that it won't be cancelled in a given piece of code. Imagine a situation when we wait for a result of
complex computations which are modelled as a cancellable future. The computations may be cancelled by one class
that manages the computations, but we also give a reference to that cancellable future to a few other classes in
the program, so that when the computations finish, those classes will be immediately informed, get the result, and
use it. But they shouldn't be able to cancel the original computations - even if the given class becomes disinterested
in the result, it should not be able to stop the computations for all others.
In such case, we can use the method <code>toUncancellable</code> - it will give us an <code>Uncancellable</code> wrapped over
the <code>promise.future</code> of our original <code>Cancellable</code> future.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The result type of the cancellable future</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.CancellableFuture" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="CancellableFuture[+T]extendsAwaitable[T]" class="anchorToMember"></a><a id="CancellableFuture[+T]:CancellableFuture[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/CancellableFuture.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="CancellableFuture.html" title="CancellableFuture is an object that for all practical uses works like a future but enables the user to cancel the operation."><span class="name">CancellableFuture</span></a><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span name="scala.concurrent.Awaitable" class="extype">Awaitable</span>[<span name="com.wire.signals.CancellableFuture.T" class="extype">T</span>]</span></span><p class="shortcomment cmt"><code>CancellableFuture</code> is an object that for all practical uses works like a future but enables the user to cancel the operation.</p><div class="fullcomment"><div class="comment cmt"><p><code>CancellableFuture</code> is an object that for all practical uses works like a future but enables the user to cancel the operation.
A cancelled future fails with <code>CancellableFuture.CancelException</code> so the subscriber can differentiate between this and other
failure reasons. It is impossible to cancel a future if it is already completed or if it is uncancellable.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p>https://github.com/wireapp/wire-signals/wiki/Overview</p></span><span class="cmt"><p><code>Uncancellable</code> for details on uncancellable futures</p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.ConstSignal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ConstSignal[V]extendsSignal[V]withNoAutowiring[V]" class="anchorToMember"></a><a id="ConstSignal[V]:ConstSignal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ConstSignal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="ConstSignal.html" title="A signal holding an immutable value."><span class="name">ConstSignal</span></a><span class="tparams">[<span name="V">V</span>]</span><span class="result"> extends <a href="Signal.html" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.ConstSignal.V" class="extype">V</span>] with <a href="NoAutowiring.html" name="com.wire.signals.NoAutowiring" id="com.wire.signals.NoAutowiring" class="extype">NoAutowiring</a>[<span name="com.wire.signals.ConstSignal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">A signal holding an immutable value.</p><div class="fullcomment"><div class="comment cmt"><p>A signal holding an immutable value.
Using const signals in flatMap chains should have better performance compared to source signals with the same value.
Since the value never changes, the subscriber function will be called only in the moment of subscription, but never
after that, so there's no need to keep the subscription.
</p></div></div></li><li class="indented0 " name="com.wire.signals.DispatchQueue" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="DispatchQueueextendsExecutionContext" class="anchorToMember"></a><a id="DispatchQueue:DispatchQueue" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/DispatchQueue.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="DispatchQueue.html" title="A thin wrapper over Scala's ExecutionContext allowing us to differentiate between the default execution context which tries to run asynchronously as many tasks as possible, and limited execution contexts, allowed to run only up to a given number of tasks at once."><span class="name">DispatchQueue</span></a><span class="result"> extends <span name="scala.concurrent.ExecutionContext" class="extype">ExecutionContext</span></span></span><p class="shortcomment cmt">A thin wrapper over Scala's <code>ExecutionContext</code> allowing us to differentiate between the default execution context
which tries to run asynchronously as many tasks as possible, and limited execution contexts, allowed to run only up
to a given number of tasks at once.</p><div class="fullcomment"><div class="comment cmt"><p>A thin wrapper over Scala's <code>ExecutionContext</code> allowing us to differentiate between the default execution context
which tries to run asynchronously as many tasks as possible, and limited execution contexts, allowed to run only up
to a given number of tasks at once.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><code>ExecutionContext</code></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventContext" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="EventContextextendsAnyRef" class="anchorToMember"></a><a id="EventContext:EventContext" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/EventContext.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="EventContext.html" title="When you subscribe to an EventSource in return you receive a Subscription."><span class="name">EventContext</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">When you subscribe to an <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a> in return you receive a <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a>.</p><div class="fullcomment"><div class="comment cmt"><p>When you subscribe to an <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a> in return you receive a <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a>. You can use that subscription
to unsubscribe from the event source or to temporarily pause receiving events. But managing a big number of
subscriptions to different event sources can be tricky. <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> comes to the rescue.</p><p>By default, every subscription is registered in a "dummy" <a href="EventContext$$Global$.html" name="com.wire.signals.EventContext.Global" id="com.wire.signals.EventContext.Global" class="extype">EventContext.Global</a> which lives for the lifetime
of the whole program and does nothing. But if instead you will create a new EventContext and use it explicitly
when subscribing or you will set it as an implicit parameter, taking over EventContext.Global, the subscription
will be registered within this new one. It will allow you to manage all registered subscriptions at once and
all registered subscriptions will be destroyed when the event context lifetime ends.</p><p>Usage of methods in the trait are explained as they are implemented in the default implementation.
All operations on an <a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a> are synchronized.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventSource" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="EventSource[E,S]extendsAnyRef" class="anchorToMember"></a><a id="EventSource[E,S]:EventSource[E,S]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/EventSource.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="EventSource.html" title=""><span class="name">EventSource</span></a><span class="tparams">[<span name="E">E</span>, <span name="S">S</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span></li><li class="indented0 " name="com.wire.signals.EventStream" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="EventStream[E]extendsEventSource[E,com.wire.signals.EventStream.EventSubscriber[E]]" class="anchorToMember"></a><a id="EventStream[E]:EventStream[E]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/EventStream.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="EventStream.html" title="An event stream of type E dispatches events (of type E) to all functions of type (E) =&gt; Unit which were registered in the event stream as its subscribers."><span class="name">EventStream</span></a><span class="tparams">[<span name="E">E</span>]</span><span class="result"> extends <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a>[<span name="com.wire.signals.EventStream.E" class="extype">E</span>, <span name="com.wire.signals.EventStream.EventSubscriber" class="extype">EventSubscriber</span>[<span name="com.wire.signals.EventStream.E" class="extype">E</span>]]</span></span><p class="shortcomment cmt">An event stream of type <code>E</code> dispatches events (of type <code>E</code>) to all functions of type <code>(E) =&gt; Unit</code> which were registered in
the event stream as its subscribers.</p><div class="fullcomment"><div class="comment cmt"><p>An event stream of type <code>E</code> dispatches events (of type <code>E</code>) to all functions of type <code>(E) =&gt; Unit</code> which were registered in
the event stream as its subscribers. It doesn't have an internal state. It provides a handful of methods which enable
the user to create new event streams by means of composing the old ones, filtering them, etc., in a way similar to how
the user can operate on standard collections, as well as to interact with Scala futures, cancellable futures, and signals.
Please note that by default an event stream is not able to receive events from the outside - that functionality belongs
to <a href="SourceStream.html" name="com.wire.signals.SourceStream" id="com.wire.signals.SourceStream" class="extype">SourceStream</a>.</p><p>An event stream may also help in sending events from one execution context to another. For example, a source stream may
receive an event in one execution context, but the function which consumes it is registered with another execution context
specified. In that case the function won't be called immediately, but in a future executed in that execution context.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><code>ExecutionContext</code></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.EventStreamWithAuxSignal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="EventStreamWithAuxSignal[A,B]extendsEventStream[(A,Option[B])]" class="anchorToMember"></a><a id="EventStreamWithAuxSignal[A,B]:EventStreamWithAuxSignal[A,B]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/EventStreamWithAuxSignal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="EventStreamWithAuxSignal.html" title="An event stream coupled with an auxiliary signal."><span class="name">EventStreamWithAuxSignal</span></a><span class="tparams">[<span name="A">A</span>, <span name="B">B</span>]</span><span class="result"> extends <a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a>[(<span name="com.wire.signals.EventStreamWithAuxSignal.A" class="extype">A</span>, <span name="scala.Option" class="extype">Option</span>[<span name="com.wire.signals.EventStreamWithAuxSignal.B" class="extype">B</span>])]</span></span><p class="shortcomment cmt">An event stream coupled with an auxiliary signal.</p><div class="fullcomment"><div class="comment cmt"><p>An event stream coupled with an auxiliary signal.
You can use it if you want to repeat some computations based on the current value of the signal every time when an event
is published in the source stream.
<code><code><code>
val aux = Signal[Int]()
val source = EventStream[Unit]()</code></code></code></p><p>val newStream = EventStreamWithAuxSignal(source, aux)
newStream.foreach { case (_, Option(n)) =&gt; /* ... */ }
<code><code><code>
Here, </code>newStream</code> extends </code>EventStream[Unit, Option[Int]]<code>.
The subscriber function registered in </code>newStream<code><code> will be called every time a new unit event is published in </code>source</code>
and it will receive a tuple of the event and the current value of <code>aux</code>: <code>Some[Int]</code> if something was already published
in the signal, or <code>None</code> if it is not initialized yet.
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>The type of events in the source stream.</p></dd><dt class="tparam">B</dt><dd class="cmt"><p>The type of values in the auxiliary signal.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.LimitedDispatchQueue" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="LimitedDispatchQueueextendsDispatchQueue" class="anchorToMember"></a><a id="LimitedDispatchQueue:LimitedDispatchQueue" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/LimitedDispatchQueue.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="LimitedDispatchQueue.html" title="A dispatch queue limiting number of concurrently executing tasks."><span class="name">LimitedDispatchQueue</span></a><span class="result"> extends <a href="DispatchQueue.html" name="com.wire.signals.DispatchQueue" id="com.wire.signals.DispatchQueue" class="extype">DispatchQueue</a></span></span><p class="shortcomment cmt">A dispatch queue limiting number of concurrently executing tasks.</p><div class="fullcomment"><div class="comment cmt"><p>A dispatch queue limiting number of concurrently executing tasks.
All tasks are executed on parent execution context, but only up to the <code>concurrencyLimit</code>.
New tasks, scheduled when the limit is reached, will wait in the queue until one of the current one finishes.
Create with one of <code>DispatchQueue.apply</code> methods.
</p></div></div></li><li class="indented0 " name="com.wire.signals.NoAutowiring" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="NoAutowiring[V]extendsAnyRef" class="anchorToMember"></a><a id="NoAutowiring[V]:NoAutowiring[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/NoAutowiring.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="NoAutowiring.html" title="By default, a new signal is initialized lazily, i.e."><span class="name">NoAutowiring</span></a><span class="tparams">[<span name="V">V</span>]</span><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">By default, a new signal is initialized lazily, i.e.</p><div class="fullcomment"><div class="comment cmt"><p>By default, a new signal is initialized lazily, i.e. only when the first subscriber function is registered in it.
You can decorate it with <code>NoAutowiring</code> to enforce initialization.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.ProxyEventStream" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="ProxyEventStream[A,E]extendsEventStream[E]withEventStream.EventSubscriber[A]" class="anchorToMember"></a><a id="ProxyEventStream[A,E]:ProxyEventStream[A,E]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ProxyEventStream.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="ProxyEventStream.html" title="A superclass for all event streams which compose other event streams into one."><span class="name">ProxyEventStream</span></a><span class="tparams">[<span name="A">A</span>, <span name="E">E</span>]</span><span class="result"> extends <a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a>[<span name="com.wire.signals.ProxyEventStream.E" class="extype">E</span>] with <span name="com.wire.signals.EventStream.EventSubscriber" class="extype">EventSubscriber</span>[<span name="com.wire.signals.ProxyEventStream.A" class="extype">A</span>]</span></span><p class="shortcomment cmt">A superclass for all event streams which compose other event streams into one.</p><div class="fullcomment"><div class="comment cmt"><p>A superclass for all event streams which compose other event streams into one.
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>The type of the events emitted by all the source streams.</p></dd><dt class="tparam">E</dt><dd class="cmt"><p>The type of the events emitted by the stream constructed from the sources.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.ProxySignal" group="Ungrouped" fullComment="no" data-isabs="true" visbl="pub"><a id="ProxySignal[V]extendsSignal[V]withSignal.SignalSubscriber" class="anchorToMember"></a><a id="ProxySignal[V]:ProxySignal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ProxySignal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">abstract </span> <span class="kind">class</span></span> <span class="symbol"><a href="ProxySignal.html" title=""><span class="name">ProxySignal</span></a><span class="tparams">[<span name="V">V</span>]</span><span class="result"> extends <a href="Signal.html" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.ProxySignal.V" class="extype">V</span>] with <span name="com.wire.signals.Signal.SignalSubscriber" class="extype">SignalSubscriber</span></span></span></li><li class="indented0 " name="com.wire.signals.RefreshingSignal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="RefreshingSignal[V]extendsSignal[V]" class="anchorToMember"></a><a id="RefreshingSignal[V]:RefreshingSignal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/RefreshingSignal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="RefreshingSignal.html" title="A signal which initializes its value by executing the loader cancellable future and then updates the value the same way every time a new refresh event is published in the associated event stream."><span class="name">RefreshingSignal</span></a><span class="tparams">[<span name="V">V</span>]</span><span class="result"> extends <a href="Signal.html" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.RefreshingSignal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">A signal which initializes its value by executing the <code>loader</code> cancellable future and then updates the value the same way
every time a new refresh event is published in the associated event stream.</p><div class="fullcomment"><div class="comment cmt"><p>A signal which initializes its value by executing the <code>loader</code> cancellable future and then updates the value the same way
every time a new refresh event is published in the associated event stream. The type of the event is not important.</p><p>A typical use case for a refreshing signal might be, for example, to inform another component that something changed
in the storage while already retrieving the updated data. In this case, the refresh event stream can be anything that
indicates the data has changed, and the loader is the query. The refresh event might even be a false positive:
then the loader function will be called but the subscriber function of the refreshing signal will not be notified as
the result of the loader is the same and so the value of the signal doesn't change.
</p></div><dl class="paramcmts block"><dt class="tparam">V</dt><dd class="cmt"><p>The value type of the signal and the result of the <code>loader</code> cancellable future.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="AggregatingSignal.html" name="com.wire.signals.AggregatingSignal" id="com.wire.signals.AggregatingSignal" class="extype">AggregatingSignal</a></p></span><span class="cmt"><p><a href="CancellableFuture.html" name="com.wire.signals.CancellableFuture" id="com.wire.signals.CancellableFuture" class="extype">CancellableFuture</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.SerialDispatchQueue" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SerialDispatchQueueextendsLimitedDispatchQueue" class="anchorToMember"></a><a id="SerialDispatchQueue:SerialDispatchQueue" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/SerialDispatchQueue.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="SerialDispatchQueue.html" title="A special case of a limited dispatch queue which allows for only one task to be executed at once."><span class="name">SerialDispatchQueue</span></a><span class="result"> extends <a href="LimitedDispatchQueue.html" name="com.wire.signals.LimitedDispatchQueue" id="com.wire.signals.LimitedDispatchQueue" class="extype">LimitedDispatchQueue</a></span></span><p class="shortcomment cmt">A special case of a limited dispatch queue which allows for only one task to be executed at once.</p><div class="fullcomment"><div class="comment cmt"><p>A special case of a limited dispatch queue which allows for only one task to be executed at once.
Use when you want to enforce the tasks to be executed in the order they were scheduled.
</p></div></div></li><li class="indented0 " name="com.wire.signals.Signal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Signal[V]extendsEventSource[V,com.wire.signals.Signal.SignalSubscriber]" class="anchorToMember"></a><a id="Signal[V]:Signal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="Signal.html" title="A signal is an event stream with a cache."><span class="name">Signal</span></a><span class="tparams">[<span name="V">V</span>]</span><span class="result"> extends <a href="EventSource.html" name="com.wire.signals.EventSource" id="com.wire.signals.EventSource" class="extype">EventSource</a>[<span name="com.wire.signals.Signal.V" class="extype">V</span>, <span name="com.wire.signals.Signal.SignalSubscriber" class="extype">SignalSubscriber</span>]</span></span><p class="shortcomment cmt">A signal is an event stream with a cache.</p><div class="fullcomment"><div class="comment cmt"><p>A signal is an event stream with a cache.</p><p>Whereas an event stream holds no internal state and just passes on events it receives, a signal keeps the last value it received.
A new subscriber function registered in an event stream will be called only when a new event is published.
A new subscriber function registered in a signal will be called immediately (or as soon as possible on the given execution context)
with the current value of the signal (unless it's not initialized yet) and then again when the value changes.
A signal is also able to compare a new value published in it with the old one - the new value will be passed on only if
it is different. Thus, a signal can help us with optimizing performance on both ends: as a cache for values which otherwise
would require expensive computations to produce them every time we need them, and as a way to ensure that subscriber functions
are called only when the value actually changes, but not when the result of the intermediate computation is the same as before.</p><p>Note that for clarity we talk about *events* in the event streams, but about *values* in signals.</p><p>An signal of the type <code>V</code> dispatches values to all functions of the type <code>(V) =&gt; Unit</code> which were registered in
the signal as its subscribers. It provides a handful of methods which enable the user to create new signals by means of composing
the old ones, filtering them, etc., in a way similar to how the user can operate on standard collections, as well as to interact with
Scala futures, cancellable futures, and event streams. Please note that by default a signal is not able to receive events from the outside -
that functionality belongs to <a href="SourceSignal.html" name="com.wire.signals.SourceSignal" id="com.wire.signals.SourceSignal" class="extype">SourceSignal</a>.
</p></div><dl class="paramcmts block"><dt class="tparam">V</dt><dd class="cmt"><p>The type of the value held in the signal.</p></dd></dl><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.SourceSignal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SourceSignal[V]extendsSignal[V]" class="anchorToMember"></a><a id="SourceSignal[V]:SourceSignal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/SourceSignal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="SourceSignal.html" title="The usual entry point for publishing values in signals."><span class="name">SourceSignal</span></a><span class="tparams">[<span name="V">V</span>]</span><span class="result"> extends <a href="Signal.html" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>[<span name="com.wire.signals.SourceSignal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">The usual entry point for publishing values in signals.</p><div class="fullcomment"><div class="comment cmt"><p>The usual entry point for publishing values in signals.</p><p>Create a new signal either using the default constructor or the <code>Signal.apply[V]()</code> method. The source signal exposes
methods you can use for changing its value. Then you can combine it with other signals and finally subscribe a function
to it which will be called initially, and then on each change of the signal's value.
</p></div><dl class="paramcmts block"><dt class="tparam">V</dt><dd class="cmt"><p>the type of the value held by the signal.</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.SourceStream" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="SourceStream[E]extendsEventStream[E]" class="anchorToMember"></a><a id="SourceStream[E]:SourceStream[E]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/SourceStream.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="SourceStream.html" title="The usual entry point for publishing events."><span class="name">SourceStream</span></a><span class="tparams">[<span name="E">E</span>]</span><span class="result"> extends <a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a>[<span name="com.wire.signals.SourceStream.E" class="extype">E</span>]</span></span><p class="shortcomment cmt">The usual entry point for publishing events.</p><div class="fullcomment"><div class="comment cmt"><p>The usual entry point for publishing events.</p><p>Create a new source stream either using the default constructor or the <code>EventStream.apply[V]()</code> method. The source stream exposes
methods you can use for publishing new events. Then you can combine it with other event streams and finally subscribe a function
to it which will receive the resulting events.
</p></div><dl class="paramcmts block"><dt class="tparam">E</dt><dd class="cmt"><p>the type of the event</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Subscription" group="Ungrouped" fullComment="yes" data-isabs="true" visbl="pub"><a id="SubscriptionextendsAnyRef" class="anchorToMember"></a><a id="Subscription:Subscription" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Subscription.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">trait</span></span> <span class="symbol"><a href="Subscription.html" title="When you add a new subscriber to your EventStream or Signal, in return you get a Subscription."><span class="name">Subscription</span></a><span class="result"> extends <span name="scala.AnyRef" class="extype">AnyRef</span></span></span><p class="shortcomment cmt">When you add a new subscriber to your <a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a> or <a href="Signal.html" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>, in return you get a <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a>.</p><div class="fullcomment"><div class="comment cmt"><p>When you add a new subscriber to your <a href="EventStream.html" name="com.wire.signals.EventStream" id="com.wire.signals.EventStream" class="extype">EventStream</a> or <a href="Signal.html" name="com.wire.signals.Signal" id="com.wire.signals.Signal" class="extype">Signal</a>, in return you get a <a href="Subscription.html" name="com.wire.signals.Subscription" id="com.wire.signals.Subscription" class="extype">Subscription</a>.
A subscription can then be used to inform the source about changes in the condition of the connection:
should it be enabled or disabled, should the subscriber be subscribed or (temporarily) unsubscribed,
or should the subscription be permanently destroyed.</p><p>It is important to destroy subscriptions when they are no longer needed, e.g. at the end of the life
of an object which subscribes to the source of events. Otherwise you may face a hidden memory leak where
no longer used data cannot be GC-ed because it is still referenced by the source of events.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p><a href="EventContext.html" name="com.wire.signals.EventContext" id="com.wire.signals.EventContext" class="extype">EventContext</a>
Implement this trait together with writing a new event source if you want to change how your event source
reacts to the aforementioned events. For an example of how to do it on a small scale, please</p></span><span class="cmt"><p><a href="CancellableFuture.html#withAutoCanceling(impliciteventContext:com.wire.signals.EventContext):com.wire.signals.Subscription" name="com.wire.signals.CancellableFuture#withAutoCanceling" id="com.wire.signals.CancellableFuture#withAutoCanceling" class="extmbr">CancellableFuture.withAutoCanceling</a></p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.ThrottledSignal" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="ThrottledSignal[V]extendsProxySignal[V]" class="anchorToMember"></a><a id="ThrottledSignal[V]:ThrottledSignal[V]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ThrottledSignal.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">class</span></span> <span class="symbol"><a href="ThrottledSignal.html" title="A signal which publishes changes of its parent signal but no more often than once during a given time interval."><span class="name">ThrottledSignal</span></a><span class="tparams">[<span name="V">V</span>]</span><span class="result"> extends <a href="ProxySignal.html" name="com.wire.signals.ProxySignal" id="com.wire.signals.ProxySignal" class="extype">ProxySignal</a>[<span name="com.wire.signals.ThrottledSignal.V" class="extype">V</span>]</span></span><p class="shortcomment cmt">A signal which publishes changes of its parent signal but no more often than once during a given time interval.</p><div class="fullcomment"><div class="comment cmt"><p>A signal which publishes changes of its parent signal but no more often than once during a given time interval.
The initial value of the parent signal will be published immediately. The first change to it will happen at the earliest
after the given delay. If the parent signal changes its value more often, the intermediate values will be ignored.</p><p>Use it e.g. for optimization of a signal chain when there is no need to react immediately to all changes to the original signal.
For example. changes in the UI could be displayed only with the speed that allows for comfortable usage of the app by the user,
but not faster.
</p></div><dl class="paramcmts block"><dt class="tparam">V</dt><dd class="cmt"><p>The value type of the signal.</p></dd></dl><dl class="attributes block"><dt>To do</dt><dd><span class="cmt"><p>Check if when the original value changes once during the delay interval, but not again after it, will that one change
      be noticed. I think it should be.</p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Uncancellable" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Uncancellable[+T]extendsCancellableFuture[T]" class="anchorToMember"></a><a id="Uncancellable[+T]:Uncancellable[T]" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Uncancellable.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="Uncancellable.html" title="A subclass of CancellableFuture which represents a subset of cancellable futures which are actually **un**cancellable."><span class="name">Uncancellable</span></a><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <a href="CancellableFuture.html" name="com.wire.signals.CancellableFuture" id="com.wire.signals.CancellableFuture" class="extype">CancellableFuture</a>[<span name="com.wire.signals.Uncancellable.T" class="extype">T</span>]</span></span><p class="shortcomment cmt">A subclass of <code>CancellableFuture</code> which represents a subset of cancellable futures which are actually **un**cancellable.</p><div class="fullcomment"><div class="comment cmt"><p>A subclass of <code>CancellableFuture</code> which represents a subset of cancellable futures which are actually **un**cancellable.
I know it means the name of the parent class is misleading, since not all cancellable futures are cancellable, but,
well, naming is a hard problem in computer science.
The reasoning here goes like this: An actually cancellable <code>CancellableFuture</code> is a wrapper over a <code>Promise</code>, not
a <code>Future</code>. We create a promise and try to fulfill it with the code given to us in one of the constructor methods.
If we succeed, the cancellable future will behave just as a regular one. But thanks to that we hold a promise,
we are able to cancel the ongoing execution of that piece of code by calling <code>tryFailure</code> on the promise.</p><p>However, in some situations cancelling will not be possible. One is of course that the future may already be completed -
with success or with failure (including that it might have been already cancelled). This is why the <code>cancel</code> method
returns a boolean - we can't be always 100% sure that calling it will actually cancel the future.</p><p>But there is also another possibility. Because of how ubiquitous futures are in the Scala standard library, it makes
sense to be able to wrap them in cancellable futures so that they can be used in the same code with the actually
cancellable futures. After all, if we're on the happy path, the two behave the same. The only difference appears
only when we try to cancel such a "cancellable" future - we don't have access to the parent promise of that future,
so we can't cancel it. Calling <code>cancel</code> on such a future will always return <code>false</code>, a callback registered with
<code>onCancel</code> will be ignored, etc.</p><p>The last case is an inverse of the second one: Sometimes we have an actually cancellable future but we want to
make sure that it won't be cancelled in a given piece of code. Imagine a situation when we wait for a result of
complex computations which are modelled as a cancellable future. The computations may be cancelled by one class
that manages the computations, but we also give a reference to that cancellable future to a few other classes in
the program, so that when the computations finish, those classes will be immediately informed, get the result, and
use it. But they shouldn't be able to cancel the original computations - even if the given class becomes disinterested
in the result, it should not be able to stop the computations for all others.
In such case, we can use the method <code>toUncancellable</code> - it will give us an <code>Uncancellable</code> wrapped over
the <code>promise.future</code> of our original <code>Cancellable</code> future.
</p></div><dl class="paramcmts block"><dt class="tparam">T</dt><dd class="cmt"><p>The result type of the cancellable future</p></dd></dl></div></li><li class="indented0 " name="com.wire.signals.UnlimitedDispatchQueue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="UnlimitedDispatchQueueextendsDispatchQueue" class="anchorToMember"></a><a id="UnlimitedDispatchQueue:UnlimitedDispatchQueue" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/UnlimitedDispatchQueue.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier">final </span> <span class="kind">class</span></span> <span class="symbol"><a href="UnlimitedDispatchQueue.html" title="A dispatch queue that simply passes all its tasks to its execution context."><span class="name">UnlimitedDispatchQueue</span></a><span class="result"> extends <a href="DispatchQueue.html" name="com.wire.signals.DispatchQueue" id="com.wire.signals.DispatchQueue" class="extype">DispatchQueue</a></span></span><p class="shortcomment cmt">A dispatch queue that simply passes all its tasks to its execution context.</p></li></ol></div><div class="values members"><h3>Value Members</h3><ol><li class="indented0 " name="com.wire.signals.AggregatingSignal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="AggregatingSignal" class="anchorToMember"></a><a id="AggregatingSignal:AggregatingSignal" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/AggregatingSignal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="AggregatingSignal$.html" title=""><span class="name">AggregatingSignal</span></a></span></li><li class="indented0 " name="com.wire.signals.CancellableFuture" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="CancellableFuture" class="anchorToMember"></a><a id="CancellableFuture:CancellableFuture" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/CancellableFuture$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="CancellableFuture$.html" title="CancellableFuture is an object that for all practical uses works like a future but enables the user to cancel the operation."><span class="name">CancellableFuture</span></a></span><p class="shortcomment cmt"><code>CancellableFuture</code> is an object that for all practical uses works like a future but enables the user to cancel the operation.</p><div class="fullcomment"><div class="comment cmt"><p><code>CancellableFuture</code> is an object that for all practical uses works like a future but enables the user to cancel the operation.
A cancelled future fails with <code>CancellableFuture.CancelException</code> so the subscriber can differentiate between thisand other
failure reasons.
</p></div><dl class="attributes block"><dt>See also</dt><dd><span class="cmt"><p>https://github.com/wireapp/wire-signals/wiki/Overview</p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.ConstSignal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ConstSignal" class="anchorToMember"></a><a id="ConstSignal:ConstSignal" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ConstSignal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ConstSignal$.html" title=""><span class="name">ConstSignal</span></a></span></li><li class="indented0 " name="com.wire.signals.DispatchQueue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="DispatchQueue" class="anchorToMember"></a><a id="DispatchQueue:DispatchQueue" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/DispatchQueue$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="DispatchQueue$.html" title=""><span class="name">DispatchQueue</span></a></span></li><li class="indented0 " name="com.wire.signals.EventContext" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="EventContext" class="anchorToMember"></a><a id="EventContext:EventContext" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/EventContext$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="EventContext$.html" title=""><span class="name">EventContext</span></a></span></li><li class="indented0 " name="com.wire.signals.EventStream" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="EventStream" class="anchorToMember"></a><a id="EventStream:EventStream" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/EventStream$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="EventStream$.html" title=""><span class="name">EventStream</span></a></span></li><li class="indented0 " name="com.wire.signals.EventStreamWithAuxSignal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="EventStreamWithAuxSignal" class="anchorToMember"></a><a id="EventStreamWithAuxSignal:EventStreamWithAuxSignal" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/EventStreamWithAuxSignal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="EventStreamWithAuxSignal$.html" title=""><span class="name">EventStreamWithAuxSignal</span></a></span></li><li class="indented0 " name="com.wire.signals.LimitedDispatchQueue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="LimitedDispatchQueue" class="anchorToMember"></a><a id="LimitedDispatchQueue:LimitedDispatchQueue" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/LimitedDispatchQueue$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="LimitedDispatchQueue$.html" title=""><span class="name">LimitedDispatchQueue</span></a></span></li><li class="indented0 " name="com.wire.signals.RefreshingSignal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="RefreshingSignal" class="anchorToMember"></a><a id="RefreshingSignal:RefreshingSignal" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/RefreshingSignal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="RefreshingSignal$.html" title=""><span class="name">RefreshingSignal</span></a></span></li><li class="indented0 " name="com.wire.signals.SerialDispatchQueue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="SerialDispatchQueue" class="anchorToMember"></a><a id="SerialDispatchQueue:SerialDispatchQueue" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/SerialDispatchQueue$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SerialDispatchQueue$.html" title=""><span class="name">SerialDispatchQueue</span></a></span></li><li class="indented0 " name="com.wire.signals.Serialized" group="Ungrouped" fullComment="yes" data-isabs="false" visbl="pub"><a id="Serialized" class="anchorToMember"></a><a id="Serialized:Serialized" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Serialized$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Serialized$.html" title="A utility object for serializing futures."><span class="name">Serialized</span></a></span><p class="shortcomment cmt">A utility object for serializing futures.</p><div class="fullcomment"><div class="comment cmt"><p>A utility object for serializing futures.</p><p>The need for this functionality comes from the fact that we can't assume an event will be processed before the next one comes,
but sometimes it is also crucial to process the next event only after the first one is done. In such case, the user can use
one of the methods of <code>Serialized</code> to schedule processing the first event, tag it with a key, and then simply use the same key
to schedule processing of the second event. The user doesn't have to know if the first event was already processed or not -
if yes, processing of the second will start immediately, if not, the processing (in the form of a future or a <a href="CancellableFuture.html" name="com.wire.signals.CancellableFuture" id="com.wire.signals.CancellableFuture" class="extype">CancellableFuture</a>)
will be attached to the end of the ongoing processing and triggered only after it's done.
</p></div><dl class="attributes block"><dt>To do</dt><dd><span class="cmt"><p><code>Serialized</code> is currently used in only one place in wire-signals, <code>FutureEventStream</code>, which in turn is used only for
      <a href="EventStream.html#mapSync[V](f:E=&gt;scala.concurrent.Future[V]):com.wire.signals.EventStream[V]" name="com.wire.signals.EventStream#mapSync" id="com.wire.signals.EventStream#mapSync" class="extmbr">EventStream.mapSync</a>, so we may think or removing this class from the library (move to extensions, maybe?).</p></span></dd></dl></div></li><li class="indented0 " name="com.wire.signals.Signal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Signal" class="anchorToMember"></a><a id="Signal:Signal" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Signal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Signal$.html" title=""><span class="name">Signal</span></a></span></li><li class="indented0 " name="com.wire.signals.SourceSignal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="SourceSignal" class="anchorToMember"></a><a id="SourceSignal:SourceSignal" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/SourceSignal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="SourceSignal$.html" title=""><span class="name">SourceSignal</span></a></span></li><li class="indented0 " name="com.wire.signals.Threading" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="Threading" class="anchorToMember"></a><a id="Threading:Threading" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/Threading$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="Threading$.html" title="Use Threading to set up the default execution context which will be later used as the parent for other dispatch queues and to run cancellable futures, event streams, and signals, if no other execution context is provided."><span class="name">Threading</span></a></span><p class="shortcomment cmt">Use <code>Threading</code> to set up the default execution context which will be later used as the parent for other
dispatch queues and to run cancellable futures, event streams, and signals, if no other execution context
is provided.</p></li><li class="indented0 " name="com.wire.signals.ThrottledSignal" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="ThrottledSignal" class="anchorToMember"></a><a id="ThrottledSignal:ThrottledSignal" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/ThrottledSignal$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="ThrottledSignal$.html" title=""><span class="name">ThrottledSignal</span></a></span></li><li class="indented0 " name="com.wire.signals.UnlimitedDispatchQueue" group="Ungrouped" fullComment="no" data-isabs="false" visbl="pub"><a id="UnlimitedDispatchQueue" class="anchorToMember"></a><a id="UnlimitedDispatchQueue:UnlimitedDispatchQueue" class="anchorToMember"></a> <span class="permalink"><a href="../../../com/wire/signals/UnlimitedDispatchQueue$.html" title="Permalink"><i class="material-icons"></i></a></span> <span class="modifier_kind"><span class="modifier"></span> <span class="kind">object</span></span> <span class="symbol"><a href="UnlimitedDispatchQueue$.html" title=""><span class="name">UnlimitedDispatchQueue</span></a></span></li></ol></div></div><div id="inheritedMembers"><div name="scala.AnyRef" class="parent"><h3>Inherited from <span name="scala.AnyRef" class="extype">AnyRef</span></h3></div><div name="scala.Any" class="parent"><h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3></div></div><div id="groupedMembers"><div name="Ungrouped" class="group"><h3>Ungrouped</h3></div></div></div><div id="tooltip"></div><div id="footer"></div></body></div></div></div></body></html>
